\hypertarget{classrlbox_1_1tainted__base__impl}{}\doxysection{rlbox\+::tainted\+\_\+base\+\_\+impl\texorpdfstring{$<$}{<} T\+\_\+\+Wrap, T, T\+\_\+\+Sbx \texorpdfstring{$>$}{>} Class Template Reference}
\label{classrlbox_1_1tainted__base__impl}\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a66385fce7ba1bd883b74d887f1028917}\label{classrlbox_1_1tainted__base__impl_a66385fce7ba1bd883b74d887f1028917}} 
auto \& {\bfseries impl} ()
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_abf804eac041d98eff1686fcb03d0a73c}\label{classrlbox_1_1tainted__base__impl_abf804eac041d98eff1686fcb03d0a73c}} 
auto \& {\bfseries impl} () const
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}\label{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}} 
auto {\bfseries UNSAFE\+\_\+unverified} ()
\begin{DoxyCompactList}\small\item\em Unwrap a tainted value without verification. This is an unsafe operation and should be used with care. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a41f8eed43072bf173cce34cd3351191e}\label{classrlbox_1_1tainted__base__impl_a41f8eed43072bf173cce34cd3351191e}} 
auto {\bfseries UNSAFE\+\_\+unverified} () const
\item 
auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ae2c69129cbb9344e7d2623129f031214}{UNSAFE\+\_\+sandboxed}} (\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\+\_\+sandbox}}$<$ T\+\_\+\+Sbx $>$ \&sandbox)
\begin{DoxyCompactList}\small\item\em Like UNSAFE\+\_\+unverified, but get the underlying sandbox representation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a2fb81eab8dc3839f351d6d89410c2350}\label{classrlbox_1_1tainted__base__impl_a2fb81eab8dc3839f351d6d89410c2350}} 
auto {\bfseries UNSAFE\+\_\+sandboxed} (\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\+\_\+sandbox}}$<$ T\+\_\+\+Sbx $>$ \&sandbox) const
\item 
\mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ac7d2f71a8fc72b922bfa1260d4a7ac94}{rlbox\+\_\+detail\+\_\+member\+\_\+and\+\_\+const}} (template$<$ size\+\_\+t N $>$ inline auto unverified\+\_\+safe\+\_\+because(const char(\&reason)\mbox{[}N\mbox{]}), \{ RLBOX\+\_\+\+UNUSED(reason);static\+\_\+assert(!std\+::is\+\_\+pointer\+\_\+v$<$ T $>$, \char`\"{}unverified\+\_\+safe\+\_\+because does not support pointers. Use \char`\"{} \char`\"{}unverified\+\_\+safe\+\_\+pointer\+\_\+because.\char`\"{});return \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\+\_\+unverified}}();\})
\begin{DoxyCompactList}\small\item\em Unwrap a tainted value without verification. This function should be used when unwrapping is safe. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_af9767a70f0e97d74c5d70a6511cff5d1}\label{classrlbox_1_1tainted__base__impl_af9767a70f0e97d74c5d70a6511cff5d1}} 
{\bfseries rlbox\+\_\+detail\+\_\+member\+\_\+and\+\_\+const} (template$<$ size\+\_\+t N $>$ inline auto unverified\+\_\+safe\+\_\+pointer\+\_\+because(size\+\_\+t count, const char(\&reason)\mbox{[}N\mbox{]}), \{ RLBOX\+\_\+\+UNUSED(reason);static\+\_\+assert(std\+::is\+\_\+pointer\+\_\+v$<$ T $>$, \char`\"{}Expected pointer type\char`\"{});using T\+\_\+\+Pointed=std\+::remove\+\_\+pointer\+\_\+t$<$ T $>$;if\+\_\+constexpr\+\_\+named(cond1, std\+::is\+\_\+pointer\+\_\+v$<$ T\+\_\+\+Pointed $>$) \{ rlbox\+\_\+detail\+\_\+static\+\_\+fail\+\_\+because(cond1, \char`\"{}There is no way to use unverified\+\_\+safe\+\_\+pointer\+\_\+because for \char`\"{} \char`\"{}\textquotesingle{}pointers to pointers\textquotesingle{} safely. Use \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a701759aedd637f48cc97a0e6ada1c8a6}{copy\+\_\+and\+\_\+verify}} instead.\char`\"{});return nullptr;\} auto ret=\mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\+\_\+unverified}}();if(ret !=nullptr) \{ size\+\_\+t bytes=sizeof(T) $\ast$count;detail\+::check\+\_\+range\+\_\+doesnt\+\_\+cross\+\_\+app\+\_\+sbx\+\_\+boundary$<$ T\+\_\+\+Sbx $>$(ret, bytes);\} return ret;\})
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_afd3ea6da54b1556e0bdfd222df1ed2e9}\label{classrlbox_1_1tainted__base__impl_afd3ea6da54b1556e0bdfd222df1ed2e9}} 
auto {\bfseries INTERNAL\+\_\+unverified\+\_\+safe} ()
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_aadcc0f6dc4114d5c9ebecff33040c3c7}\label{classrlbox_1_1tainted__base__impl_aadcc0f6dc4114d5c9ebecff33040c3c7}} 
auto {\bfseries INTERNAL\+\_\+unverified\+\_\+safe} () const
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ac11254da0346088f7e2ccfdccf87deb1}\label{classrlbox_1_1tainted__base__impl_ac11254da0346088f7e2ccfdccf87deb1}} 
{\bfseries Binary\+Op\+Val\+And\+Ptr} (+)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ab64e73357c9a9387ca281d31e17bc490}\label{classrlbox_1_1tainted__base__impl_ab64e73357c9a9387ca281d31e17bc490}} 
{\bfseries Binary\+Op\+Val\+And\+Ptr} (-\/)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ac13751ef39495b930584164f841c540d}\label{classrlbox_1_1tainted__base__impl_ac13751ef39495b930584164f841c540d}} 
Binary\+Op $\ast$ {\bfseries Binary\+Op} (/);Binary\+Op(\%
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a03f7e6cbb4ac6cc48b5f523c69863fee}\label{classrlbox_1_1tainted__base__impl_a03f7e6cbb4ac6cc48b5f523c69863fee}} 
Binary\+Op$^\wedge$ {\bfseries Binary\+Op} (\&);Binary\+Op($\vert$
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a100c45337a0ad48eb18ac977edb8cc48}\label{classrlbox_1_1tainted__base__impl_a100c45337a0ad48eb18ac977edb8cc48}} 
{\bfseries Binary\+Op} ($<$$<$)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a19409368320571c2d44e5b41620fbe93}\label{classrlbox_1_1tainted__base__impl_a19409368320571c2d44e5b41620fbe93}} 
{\bfseries Binary\+Op} ($>$ $>$)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a15ced8f568f8899e55b6354f620cbc7c}\label{classrlbox_1_1tainted__base__impl_a15ced8f568f8899e55b6354f620cbc7c}} 
{\bfseries Compound\+Assignment\+Op} (+)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a254df7254438c313621ff1a689dd5c34}\label{classrlbox_1_1tainted__base__impl_a254df7254438c313621ff1a689dd5c34}} 
{\bfseries Compound\+Assignment\+Op} (-\/)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a80fe4331b06226cf5e5187cf806a36e5}\label{classrlbox_1_1tainted__base__impl_a80fe4331b06226cf5e5187cf806a36e5}} 
Compound\+Assignment\+Op $\ast$ {\bfseries Compound\+Assignment\+Op} (/);Compound\+Assignment\+Op(\%
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a695650ceddb22aee9f17b290e721dbd8}\label{classrlbox_1_1tainted__base__impl_a695650ceddb22aee9f17b290e721dbd8}} 
Compound\+Assignment\+Op$^\wedge$ {\bfseries Compound\+Assignment\+Op} (\&);Compound\+Assignment\+Op($\vert$
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ac234712a7d68b938c9c2f34bd4f96d73}\label{classrlbox_1_1tainted__base__impl_ac234712a7d68b938c9c2f34bd4f96d73}} 
{\bfseries Compound\+Assignment\+Op} ($<$$<$)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a9d9190fa8cfeadd75e5352a050b021d2}\label{classrlbox_1_1tainted__base__impl_a9d9190fa8cfeadd75e5352a050b021d2}} 
{\bfseries Compound\+Assignment\+Op} ($>$ $>$)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a6c8dca7aef6cbf28dec6cba42963e76a}\label{classrlbox_1_1tainted__base__impl_a6c8dca7aef6cbf28dec6cba42963e76a}} 
{\bfseries Pre\+Inc\+Dec\+Ops} (+)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ab9decc76ea24942932c7288d2ee257c3}\label{classrlbox_1_1tainted__base__impl_ab9decc76ea24942932c7288d2ee257c3}} 
{\bfseries Pre\+Inc\+Dec\+Ops} (-\/)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a2ccdf93dd8466df3985c4f7c9225af08}\label{classrlbox_1_1tainted__base__impl_a2ccdf93dd8466df3985c4f7c9225af08}} 
{\bfseries Post\+Inc\+Dec\+Ops} (+)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a091f18be8cd32b34bec75322364e1f1d}\label{classrlbox_1_1tainted__base__impl_a091f18be8cd32b34bec75322364e1f1d}} 
{\bfseries Post\+Inc\+Dec\+Ops} (-\/)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a950a68721c252366df818c0cbf4da4c6}\label{classrlbox_1_1tainted__base__impl_a950a68721c252366df818c0cbf4da4c6}} 
Boolean\+Binary\+Op \&\& {\bfseries Boolean\+Binary\+Op} ($\vert$$\vert$);\#define Unary\+Op(op\+Symbol) Unary\+Op(-\/
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ac450c85ec8fa3c5046bcf3fb7aeca2d1}\label{classrlbox_1_1tainted__base__impl_ac450c85ec8fa3c5046bcf3fb7aeca2d1}} 
{\bfseries Unary\+Op} ($\sim$)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a257ae6c0b4a0fe1b1639044a572a038b}\label{classrlbox_1_1tainted__base__impl_a257ae6c0b4a0fe1b1639044a572a038b}} 
{\bfseries Compare\+Op} (==, true)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a3d04a736a337294fc02a13baef2d78db}\label{classrlbox_1_1tainted__base__impl_a3d04a736a337294fc02a13baef2d78db}} 
{\bfseries Compare\+Op} (!=, true)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ac91498bde8eb4e3a384c666a65d5e7c0}\label{classrlbox_1_1tainted__base__impl_ac91498bde8eb4e3a384c666a65d5e7c0}} 
{\bfseries Compare\+Op} ($<$, false)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a2665ce9ccc644be5556c05fb26470468}\label{classrlbox_1_1tainted__base__impl_a2665ce9ccc644be5556c05fb26470468}} 
{\bfseries Compare\+Op} ($<$=, false)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a461a58872313be13c882039a4d286145}\label{classrlbox_1_1tainted__base__impl_a461a58872313be13c882039a4d286145}} 
{\bfseries Compare\+Op} ($>$, false)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_af85745a199b95587d0d750439fae25bd}\label{classrlbox_1_1tainted__base__impl_af85745a199b95587d0d750439fae25bd}} 
{\bfseries Compare\+Op} ($>$=, false)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a0867903c2ba81b50c85f142682ef1c0c}\label{classrlbox_1_1tainted__base__impl_a0867903c2ba81b50c85f142682ef1c0c}} 
{\footnotesize template$<$typename T\+\_\+\+Rhs $>$ }\\const T\+\_\+\+Op\+Subscript\+Arr\+Ret \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (T\+\_\+\+Rhs \&\&rhs) const
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ae684874ca4a58d905b827bcd885a5877}\label{classrlbox_1_1tainted__base__impl_ae684874ca4a58d905b827bcd885a5877}} 
{\footnotesize template$<$typename T\+\_\+\+Rhs $>$ }\\T\+\_\+\+Op\+Subscript\+Arr\+Ret \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (T\+\_\+\+Rhs \&\&rhs)
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a713a54b248f462704a77f0697d395e0c}\label{classrlbox_1_1tainted__base__impl_a713a54b248f462704a77f0697d395e0c}} 
\mbox{\hyperlink{classrlbox_1_1tainted__volatile}{T\+\_\+\+Op\+Deref\+Ret}} \& {\bfseries operator$\ast$} () const
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a4359f7609e90d48ea9d76d923f0baf7c}\label{classrlbox_1_1tainted__base__impl_a4359f7609e90d48ea9d76d923f0baf7c}} 
\mbox{\hyperlink{classrlbox_1_1tainted__volatile}{T\+\_\+\+Op\+Deref\+Ret}} \& {\bfseries operator$\ast$} ()
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a3e8fdb261d771cb7b5c9af33fe52ff35}\label{classrlbox_1_1tainted__base__impl_a3e8fdb261d771cb7b5c9af33fe52ff35}} 
auto {\bfseries operator-\/$>$} () const
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a52c2403f1851a0e2d295a712d8d10029}\label{classrlbox_1_1tainted__base__impl_a52c2403f1851a0e2d295a712d8d10029}} 
auto {\bfseries operator-\/$>$} ()
\item 
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a05eaec33cccaad9bc15e014d6c25d695}\label{classrlbox_1_1tainted__base__impl_a05eaec33cccaad9bc15e014d6c25d695}} 
auto {\bfseries operator!} ()
\item 
{\footnotesize template$<$typename T\+\_\+\+Func $>$ }\\auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a701759aedd637f48cc97a0e6ada1c8a6}{copy\+\_\+and\+\_\+verify}} (T\+\_\+\+Func verifier) const
\begin{DoxyCompactList}\small\item\em Copy tainted value from sandbox and verify it. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+\_\+\+Func $>$ }\\auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a76e49089d448ba0cfa7ef6d7c1e2d288}{copy\+\_\+and\+\_\+verify\+\_\+range}} (T\+\_\+\+Func verifier, std\+::size\+\_\+t count) const
\begin{DoxyCompactList}\small\item\em Copy a range of tainted values from sandbox and verify them. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+\_\+\+Func $>$ }\\auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_aa377cc4d0ea6768ada5032234ac89aab}{copy\+\_\+and\+\_\+verify\+\_\+string}} (T\+\_\+\+Func verifier) const
\begin{DoxyCompactList}\small\item\em Copy a tainted string from sandbox and verify it. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+\_\+\+Func $>$ }\\auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ad34419b3444d0bf37e25ecf7d37fbe0b}{copy\+\_\+and\+\_\+verify\+\_\+address}} (T\+\_\+\+Func verifier)
\begin{DoxyCompactList}\small\item\em Copy a tainted pointer from sandbox and verify the address. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+\_\+\+Func $>$ }\\auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a4f739a0994af23036cce2d06b10953ee}{copy\+\_\+and\+\_\+verify\+\_\+buffer\+\_\+address}} (T\+\_\+\+Func verifier, std\+::size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Copy a tainted pointer to a buffer from sandbox and verify the address. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a701759aedd637f48cc97a0e6ada1c8a6}\label{classrlbox_1_1tainted__base__impl_a701759aedd637f48cc97a0e6ada1c8a6}} 
\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}!copy\_and\_verify@{copy\_and\_verify}}
\index{copy\_and\_verify@{copy\_and\_verify}!rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsubsection{\texorpdfstring{copy\_and\_verify()}{copy\_and\_verify()}}
{\footnotesize\ttfamily template$<$template$<$ typename, typename $>$ typename T\+\_\+\+Wrap, typename T , typename T\+\_\+\+Sbx $>$ \\
template$<$typename T\+\_\+\+Func $>$ \\
auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{rlbox\+::tainted\+\_\+base\+\_\+impl}}$<$ T\+\_\+\+Wrap, T, T\+\_\+\+Sbx $>$\+::copy\+\_\+and\+\_\+verify (\begin{DoxyParamCaption}\item[{T\+\_\+\+Func}]{verifier }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Copy tainted value from sandbox and verify it. 


\begin{DoxyParams}{Parameters}
{\em verifer} & Function used to verify the copied value. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T\+\_\+\+Func} & the type of the verifier. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
Whatever the verifier function returns. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ad34419b3444d0bf37e25ecf7d37fbe0b}\label{classrlbox_1_1tainted__base__impl_ad34419b3444d0bf37e25ecf7d37fbe0b}} 
\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}!copy\_and\_verify\_address@{copy\_and\_verify\_address}}
\index{copy\_and\_verify\_address@{copy\_and\_verify\_address}!rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsubsection{\texorpdfstring{copy\_and\_verify\_address()}{copy\_and\_verify\_address()}}
{\footnotesize\ttfamily template$<$template$<$ typename, typename $>$ typename T\+\_\+\+Wrap, typename T , typename T\+\_\+\+Sbx $>$ \\
template$<$typename T\+\_\+\+Func $>$ \\
auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{rlbox\+::tainted\+\_\+base\+\_\+impl}}$<$ T\+\_\+\+Wrap, T, T\+\_\+\+Sbx $>$\+::copy\+\_\+and\+\_\+verify\+\_\+address (\begin{DoxyParamCaption}\item[{T\+\_\+\+Func}]{verifier }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy a tainted pointer from sandbox and verify the address. 

This function is useful if you need to verify physical bits representing the address of a pointer. Other APIs such as copy\+\_\+and\+\_\+verify performs a deep copy and changes the address bits.


\begin{DoxyParams}{Parameters}
{\em verifier} & Function used to verify the copied value. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T\+\_\+\+Func} & the type of the verifier {\ttfamily T\+\_\+\+Ret($\ast$)(uintptr\+\_\+t)} \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
Whatever the verifier function returns. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a4f739a0994af23036cce2d06b10953ee}\label{classrlbox_1_1tainted__base__impl_a4f739a0994af23036cce2d06b10953ee}} 
\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}!copy\_and\_verify\_buffer\_address@{copy\_and\_verify\_buffer\_address}}
\index{copy\_and\_verify\_buffer\_address@{copy\_and\_verify\_buffer\_address}!rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsubsection{\texorpdfstring{copy\_and\_verify\_buffer\_address()}{copy\_and\_verify\_buffer\_address()}}
{\footnotesize\ttfamily template$<$template$<$ typename, typename $>$ typename T\+\_\+\+Wrap, typename T , typename T\+\_\+\+Sbx $>$ \\
template$<$typename T\+\_\+\+Func $>$ \\
auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{rlbox\+::tainted\+\_\+base\+\_\+impl}}$<$ T\+\_\+\+Wrap, T, T\+\_\+\+Sbx $>$\+::copy\+\_\+and\+\_\+verify\+\_\+buffer\+\_\+address (\begin{DoxyParamCaption}\item[{T\+\_\+\+Func}]{verifier,  }\item[{std\+::size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy a tainted pointer to a buffer from sandbox and verify the address. 

This function is useful if you need to verify physical bits representing the address of a buffer. Other APIs such as copy\+\_\+and\+\_\+verify performs a deep copy and changes the address bits.


\begin{DoxyParams}{Parameters}
{\em verifier} & Function used to verify the copied value. \\
\hline
{\em size} & Size of the buffer. Buffer with length size is expected to fit inside sandbox memory. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T\+\_\+\+Func} & the type of the verifier {\ttfamily T\+\_\+\+Ret($\ast$)(uintptr\+\_\+t)} \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
Whatever the verifier function returns. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_a76e49089d448ba0cfa7ef6d7c1e2d288}\label{classrlbox_1_1tainted__base__impl_a76e49089d448ba0cfa7ef6d7c1e2d288}} 
\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}!copy\_and\_verify\_range@{copy\_and\_verify\_range}}
\index{copy\_and\_verify\_range@{copy\_and\_verify\_range}!rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsubsection{\texorpdfstring{copy\_and\_verify\_range()}{copy\_and\_verify\_range()}}
{\footnotesize\ttfamily template$<$template$<$ typename, typename $>$ typename T\+\_\+\+Wrap, typename T , typename T\+\_\+\+Sbx $>$ \\
template$<$typename T\+\_\+\+Func $>$ \\
auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{rlbox\+::tainted\+\_\+base\+\_\+impl}}$<$ T\+\_\+\+Wrap, T, T\+\_\+\+Sbx $>$\+::copy\+\_\+and\+\_\+verify\+\_\+range (\begin{DoxyParamCaption}\item[{T\+\_\+\+Func}]{verifier,  }\item[{std\+::size\+\_\+t}]{count }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Copy a range of tainted values from sandbox and verify them. 


\begin{DoxyParams}{Parameters}
{\em verifer} & Function used to verify the copied value. \\
\hline
{\em count} & Number of elements to copy. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T\+\_\+\+Func} & the type of the verifier. If the tainted type is {\ttfamily int$\ast$} then {\ttfamily T\+\_\+\+Func = T\+\_\+\+Ret($\ast$)(unique\+\_\+ptr\texorpdfstring{$<$}{<}int\mbox{[}\mbox{]}\texorpdfstring{$>$}{>})}. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
Whatever the verifier function returns. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_aa377cc4d0ea6768ada5032234ac89aab}\label{classrlbox_1_1tainted__base__impl_aa377cc4d0ea6768ada5032234ac89aab}} 
\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}!copy\_and\_verify\_string@{copy\_and\_verify\_string}}
\index{copy\_and\_verify\_string@{copy\_and\_verify\_string}!rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsubsection{\texorpdfstring{copy\_and\_verify\_string()}{copy\_and\_verify\_string()}}
{\footnotesize\ttfamily template$<$template$<$ typename, typename $>$ typename T\+\_\+\+Wrap, typename T , typename T\+\_\+\+Sbx $>$ \\
template$<$typename T\+\_\+\+Func $>$ \\
auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{rlbox\+::tainted\+\_\+base\+\_\+impl}}$<$ T\+\_\+\+Wrap, T, T\+\_\+\+Sbx $>$\+::copy\+\_\+and\+\_\+verify\+\_\+string (\begin{DoxyParamCaption}\item[{T\+\_\+\+Func}]{verifier }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Copy a tainted string from sandbox and verify it. 


\begin{DoxyParams}{Parameters}
{\em verifer} & Function used to verify the copied value. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T\+\_\+\+Func} & the type of the verifier either {\ttfamily T\+\_\+\+Ret($\ast$)(unique\+\_\+ptr\texorpdfstring{$<$}{<}char\mbox{[}\mbox{]}\texorpdfstring{$>$}{>})} or {\ttfamily T\+\_\+\+Ret($\ast$)(std\+::string)} \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
Whatever the verifier function returns. 
\end{DoxyReturn}
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ac7d2f71a8fc72b922bfa1260d4a7ac94}\label{classrlbox_1_1tainted__base__impl_ac7d2f71a8fc72b922bfa1260d4a7ac94}} 
\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}!rlbox\_detail\_member\_and\_const@{rlbox\_detail\_member\_and\_const}}
\index{rlbox\_detail\_member\_and\_const@{rlbox\_detail\_member\_and\_const}!rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsubsection{\texorpdfstring{rlbox\_detail\_member\_and\_const()}{rlbox\_detail\_member\_and\_const()}}
{\footnotesize\ttfamily template$<$template$<$ typename, typename $>$ typename T\+\_\+\+Wrap, typename T , typename T\+\_\+\+Sbx $>$ \\
\mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{rlbox\+::tainted\+\_\+base\+\_\+impl}}$<$ T\+\_\+\+Wrap, T, T\+\_\+\+Sbx $>$\+::rlbox\+\_\+detail\+\_\+member\+\_\+and\+\_\+const (\begin{DoxyParamCaption}\item[{template$<$ size\+\_\+t N $>$ inline auto }]{unverified\+\_\+safe\+\_\+becauseconst char(\&reason)\mbox{[}\+N\mbox{]},  }\item[{\{ RLBOX\+\_\+\+UNUSED(reason);static\+\_\+assert(!std\+::is\+\_\+pointer\+\_\+v$<$ T $>$, \char`\"{}unverified\+\_\+safe\+\_\+because does not support pointers. Use \char`\"{} \char`\"{}unverified\+\_\+safe\+\_\+pointer\+\_\+because.\char`\"{});return \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\+\_\+unverified}}();\}}]{ }\end{DoxyParamCaption})}



Unwrap a tainted value without verification. This function should be used when unwrapping is safe. 


\begin{DoxyParams}{Parameters}
{\em reason} & An explanation why the unverified unwrapping is safe. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classrlbox_1_1tainted__base__impl_ae2c69129cbb9344e7d2623129f031214}\label{classrlbox_1_1tainted__base__impl_ae2c69129cbb9344e7d2623129f031214}} 
\index{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}!UNSAFE\_sandboxed@{UNSAFE\_sandboxed}}
\index{UNSAFE\_sandboxed@{UNSAFE\_sandboxed}!rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$@{rlbox::tainted\_base\_impl$<$ T\_Wrap, T, T\_Sbx $>$}}
\doxysubsubsection{\texorpdfstring{UNSAFE\_sandboxed()}{UNSAFE\_sandboxed()}}
{\footnotesize\ttfamily template$<$template$<$ typename, typename $>$ typename T\+\_\+\+Wrap, typename T , typename T\+\_\+\+Sbx $>$ \\
auto \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{rlbox\+::tainted\+\_\+base\+\_\+impl}}$<$ T\+\_\+\+Wrap, T, T\+\_\+\+Sbx $>$\+::UNSAFE\+\_\+sandboxed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\+\_\+sandbox}}$<$ T\+\_\+\+Sbx $>$ \&}]{sandbox }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Like UNSAFE\+\_\+unverified, but get the underlying sandbox representation. 


\begin{DoxyParams}{Parameters}
{\em sandbox} & Reference to sandbox.\\
\hline
\end{DoxyParams}
For the Wasm-\/based sandbox, this function additionally validates the unwrapped value against the machine model of the sandbox (LP32). 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/d/hack/rlbox\+\_\+sandboxing\+\_\+api/code/include/rlbox.\+hpp\end{DoxyCompactItemize}
