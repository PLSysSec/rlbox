\hypertarget{rlbox__policy__types_8hpp_source}{}\doxysection{rlbox\+\_\+policy\+\_\+types.\+hpp}
\label{rlbox__policy__types_8hpp_source}\index{/home/d/hack/rlbox\_sandboxing\_api/code/include/rlbox\_policy\_types.hpp@{/home/d/hack/rlbox\_sandboxing\_api/code/include/rlbox\_policy\_types.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 \textcolor{comment}{// IWYU pragma: private, include "{}rlbox.hpp"{}}}
\DoxyCodeLine{3 \textcolor{comment}{// IWYU pragma: friend "{}rlbox\_.*\(\backslash\).hpp"{}}}
\DoxyCodeLine{4 }
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include "{}rlbox\_helpers.hpp"{}}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}rlbox\_struct\_support.hpp"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}rlbox\_types.hpp"{}}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{keyword}{namespace }rlbox \{}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{keyword}{namespace }callback\_detail \{}
\DoxyCodeLine{15 }
\DoxyCodeLine{16   \textcolor{comment}{// Compute the expected type of the callback}}
\DoxyCodeLine{17   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Sbx, \textcolor{keyword}{typename} T\_Ret, \textcolor{keyword}{typename}... T\_Args>}
\DoxyCodeLine{18   \textcolor{keyword}{using} T\_Cb =}
\DoxyCodeLine{19     std::conditional\_t<std::is\_void\_v<T\_Ret>, void, tainted<T\_Ret, T\_Sbx>> (*)(}
\DoxyCodeLine{20       rlbox\_sandbox<T\_Sbx>\&,}
\DoxyCodeLine{21       tainted<T\_Args, T\_Sbx>...);}
\DoxyCodeLine{22 }
\DoxyCodeLine{23   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Sbx, \textcolor{keyword}{typename} T\_Ret, \textcolor{keyword}{typename}... T\_Args>}
\DoxyCodeLine{24   T\_Cb<T\_Sbx, T\_Ret, T\_Args...> callback\_type\_helper(T\_Ret (*)(T\_Args...));}
\DoxyCodeLine{25 }
\DoxyCodeLine{26   \textcolor{comment}{// Compute the expected type of the interceptor}}
\DoxyCodeLine{27   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Sbx, \textcolor{keyword}{typename} T\_Ret, \textcolor{keyword}{typename}... T\_Args>}
\DoxyCodeLine{28   \textcolor{keyword}{using} T\_I = detail::convert\_to\_sandbox\_equivalent\_t<T\_Ret, T\_Sbx> (*)(}
\DoxyCodeLine{29     detail::convert\_to\_sandbox\_equivalent\_t<T\_Args, T\_Sbx>...);}
\DoxyCodeLine{30 }
\DoxyCodeLine{31   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Sbx, \textcolor{keyword}{typename} T\_Ret, \textcolor{keyword}{typename}... T\_Args>}
\DoxyCodeLine{32   T\_I<T\_Sbx, T\_Ret, T\_Args...> interceptor\_type\_helper(T\_Ret (*)(T\_Args...));}
\DoxyCodeLine{33 \}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{36 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}}
\DoxyCodeLine{37 \{}
\DoxyCodeLine{38   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{39 }
\DoxyCodeLine{40 \textcolor{keyword}{private}:}
\DoxyCodeLine{41   \mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}* sandbox;}
\DoxyCodeLine{42 }
\DoxyCodeLine{43   \textcolor{keyword}{using} T\_Callback =}
\DoxyCodeLine{44     \textcolor{keyword}{decltype}(callback\_detail::callback\_type\_helper<T\_Sbx>(std::declval<T>()));}
\DoxyCodeLine{45   T\_Callback callback;}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   \textcolor{comment}{// The interceptor is the function that runs between the sandbox invoking the}}
\DoxyCodeLine{48   \textcolor{comment}{// callback and the actual callback running The interceptor is responsible for}}
\DoxyCodeLine{49   \textcolor{comment}{// wrapping and converting callback arguments, returns etc. to their}}
\DoxyCodeLine{50   \textcolor{comment}{// appropriate representations}}
\DoxyCodeLine{51   \textcolor{keyword}{using} T\_Interceptor =}
\DoxyCodeLine{52     \textcolor{keyword}{decltype}(callback\_detail::interceptor\_type\_helper<T\_Sbx>(}
\DoxyCodeLine{53       std::declval<T>()));}
\DoxyCodeLine{54   T\_Interceptor callback\_interceptor;}
\DoxyCodeLine{55 }
\DoxyCodeLine{56   \textcolor{comment}{// The trampoline is the internal sandbox representation of the callback}}
\DoxyCodeLine{57   \textcolor{comment}{// Depending on the sandbox type, this could be the callback pointer directly}}
\DoxyCodeLine{58   \textcolor{comment}{// or a trampoline function that gates exits from the sandbox.}}
\DoxyCodeLine{59   \textcolor{keyword}{using} T\_Trampoline = detail::convert\_to\_sandbox\_equivalent\_t<T, T\_Sbx>;}
\DoxyCodeLine{60   T\_Trampoline callback\_trampoline;}
\DoxyCodeLine{61 }
\DoxyCodeLine{62   \textcolor{comment}{// The unique key representing the callback to pass to unregister\_callback on}}
\DoxyCodeLine{63   \textcolor{comment}{// destruction}}
\DoxyCodeLine{64   \textcolor{keywordtype}{void}* key;}
\DoxyCodeLine{65 }
\DoxyCodeLine{66   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} move\_obj(\mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}\&\& other)}
\DoxyCodeLine{67   \{}
\DoxyCodeLine{68     sandbox = other.sandbox;}
\DoxyCodeLine{69     callback = other.callback;}
\DoxyCodeLine{70     callback\_interceptor = other.callback\_interceptor;}
\DoxyCodeLine{71     callback\_trampoline = other.callback\_trampoline;}
\DoxyCodeLine{72     key = other.key;}
\DoxyCodeLine{73     other.sandbox = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{74     other.callback = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{75     other.callback\_interceptor = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{76     other.callback\_trampoline = 0;}
\DoxyCodeLine{77     other.key = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{78   \}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Ret, \textcolor{keyword}{typename}... T\_Args>}
\DoxyCodeLine{81   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} unregister\_helper(T\_Ret (*)(T\_Args...))}
\DoxyCodeLine{82   \{}
\DoxyCodeLine{83     \textcolor{keywordflow}{if} (callback != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{84       \textcolor{comment}{// Don't need to worry about race between unregister and move as}}
\DoxyCodeLine{85       \textcolor{comment}{// 1) this will not happen in a correctly written program}}
\DoxyCodeLine{86       \textcolor{comment}{// 2) if this does happen, the worst that can happen is an invocation of a}}
\DoxyCodeLine{87       \textcolor{comment}{// null function pointer, which causes a crash that cannot be exploited}}
\DoxyCodeLine{88       \textcolor{comment}{// for RCE}}
\DoxyCodeLine{89       sandbox-\/>template unregister\_callback<T\_Ret, T\_Args...>(key);}
\DoxyCodeLine{90       sandbox = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{91       callback = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{92       callback\_interceptor = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{93       callback\_trampoline = 0;}
\DoxyCodeLine{94       key = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96   \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98   \textcolor{keyword}{inline} T\_Callback get\_raw\_value() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} callback; \}}
\DoxyCodeLine{99   \textcolor{keyword}{inline} T\_Trampoline get\_raw\_sandbox\_value() \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{100   \{}
\DoxyCodeLine{101     \textcolor{keywordflow}{return} callback\_trampoline;}
\DoxyCodeLine{102   \}}
\DoxyCodeLine{103   \textcolor{keyword}{inline} T\_Callback get\_raw\_value() \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} callback; \}}
\DoxyCodeLine{104   \textcolor{keyword}{inline} T\_Trampoline get\_raw\_sandbox\_value() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{105   \{}
\DoxyCodeLine{106     \textcolor{keywordflow}{return} callback\_trampoline;}
\DoxyCodeLine{107   \}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109   \textcolor{comment}{// Keep constructor private as only rlbox\_sandbox should be able to create}}
\DoxyCodeLine{110   \textcolor{comment}{// this object}}
\DoxyCodeLine{111   \mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}* p\_sandbox,}
\DoxyCodeLine{112                    T\_Callback p\_callback,}
\DoxyCodeLine{113                    T\_Interceptor p\_callback\_interceptor,}
\DoxyCodeLine{114                    T\_Trampoline p\_callback\_trampoline,}
\DoxyCodeLine{115                    \textcolor{keywordtype}{void}* p\_key)}
\DoxyCodeLine{116     : sandbox(p\_sandbox)}
\DoxyCodeLine{117     , callback(p\_callback)}
\DoxyCodeLine{118     , callback\_interceptor(p\_callback\_interceptor)}
\DoxyCodeLine{119     , callback\_trampoline(p\_callback\_trampoline)}
\DoxyCodeLine{120     , key(p\_key)}
\DoxyCodeLine{121   \{}
\DoxyCodeLine{122     detail::dynamic\_check(sandbox != \textcolor{keyword}{nullptr},}
\DoxyCodeLine{123                           \textcolor{stringliteral}{"{}Unexpected null sandbox when creating a callback"{}});}
\DoxyCodeLine{124   \}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{keyword}{public}:}
\DoxyCodeLine{127   \mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}()}
\DoxyCodeLine{128     : sandbox(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{129     , callback(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{130     , callback\_interceptor(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{131     , callback\_trampoline(0)}
\DoxyCodeLine{132     , key(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{133   \{\}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135   \mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}(\mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}\&\& other)}
\DoxyCodeLine{136   \{}
\DoxyCodeLine{137     move\_obj(std::forward<sandbox\_callback>(other));}
\DoxyCodeLine{138   \}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}\& operator=(\mbox{\hyperlink{classrlbox_1_1sandbox__callback}{sandbox\_callback}}\&\& other)}
\DoxyCodeLine{141   \{}
\DoxyCodeLine{142     \textcolor{keywordflow}{if} (\textcolor{keyword}{this} != \&other) \{}
\DoxyCodeLine{143       move\_obj(std::forward<sandbox\_callback>(other));}
\DoxyCodeLine{144     \}}
\DoxyCodeLine{145     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{146   \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148   \textcolor{keywordtype}{void} unregister()}
\DoxyCodeLine{149   \{}
\DoxyCodeLine{150     T dummy = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{151     unregister\_helper(dummy);}
\DoxyCodeLine{152   \}}
\DoxyCodeLine{153 }
\DoxyCodeLine{154   \mbox{\hyperlink{classrlbox_1_1sandbox__callback}{\string~sandbox\_callback}}() \{ unregister(); \}}
\DoxyCodeLine{155 }
\DoxyCodeLine{159   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classrlbox_1_1sandbox__callback_ad587e0c79682c3f92c90bfdf7c974322}{is\_registered}}() const noexcept \{ \textcolor{keywordflow}{return} get\_raw\_value() != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{160 }
\DoxyCodeLine{165   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1sandbox__callback_a9d7a4e08413d3989ce8633ea459b1110}{UNSAFE\_unverified}}() const noexcept \{ \textcolor{keywordflow}{return} get\_raw\_value(); \}}
\DoxyCodeLine{172   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1sandbox__callback_a0a71e99d85bd22cd642327017c863b26}{UNSAFE\_sandboxed}}(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{173   \{}
\DoxyCodeLine{174     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{175     \textcolor{keywordflow}{return} get\_raw\_sandbox\_value();}
\DoxyCodeLine{176   \}}
\DoxyCodeLine{177   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1sandbox__callback_a9d7a4e08413d3989ce8633ea459b1110}{UNSAFE\_unverified}}() noexcept \{ \textcolor{keywordflow}{return} get\_raw\_value(); \}}
\DoxyCodeLine{178   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1sandbox__callback_a0a71e99d85bd22cd642327017c863b26}{UNSAFE\_sandboxed}}(rlbox\_sandbox<T\_Sbx>\& sandbox) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{179   \{}
\DoxyCodeLine{180     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{181     \textcolor{keywordflow}{return} get\_raw\_sandbox\_value();}
\DoxyCodeLine{182   \}}
\DoxyCodeLine{183 \};}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{186 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}}
\DoxyCodeLine{187 \{}
\DoxyCodeLine{188   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{189 }
\DoxyCodeLine{190 \textcolor{keyword}{private}:}
\DoxyCodeLine{191   \mbox{\hyperlink{classrlbox_1_1app__pointer__map}{app\_pointer\_map<typename T\_Sbx::T\_PointerType>}}* map;}
\DoxyCodeLine{192   \textcolor{keyword}{typename} T\_Sbx::T\_PointerType idx;}
\DoxyCodeLine{193   T idx\_unsandboxed;}
\DoxyCodeLine{194 }
\DoxyCodeLine{195   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} move\_obj(\mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}\&\& other)}
\DoxyCodeLine{196   \{}
\DoxyCodeLine{197     map = other.map;}
\DoxyCodeLine{198     idx = other.idx;}
\DoxyCodeLine{199     idx\_unsandboxed = other.idx\_unsandboxed;}
\DoxyCodeLine{200     other.map = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{201     other.idx = 0;}
\DoxyCodeLine{202     other.idx\_unsandboxed = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{203   \}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205   \textcolor{keyword}{inline} T get\_raw\_value() \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{206   \{}
\DoxyCodeLine{207     \textcolor{keywordflow}{return} to\_tainted().get\_raw\_value();}
\DoxyCodeLine{208   \}}
\DoxyCodeLine{209   \textcolor{keyword}{inline} \textcolor{keyword}{typename} T\_Sbx::T\_PointerType get\_raw\_sandbox\_value() \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{210   \{}
\DoxyCodeLine{211     \textcolor{keywordflow}{return} idx;}
\DoxyCodeLine{212   \}}
\DoxyCodeLine{213   \textcolor{keyword}{inline} T get\_raw\_value() \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} to\_tainted().get\_raw\_value(); \}}
\DoxyCodeLine{214   \textcolor{keyword}{inline} \textcolor{keyword}{typename} T\_Sbx::T\_PointerType get\_raw\_sandbox\_value() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{215   \{}
\DoxyCodeLine{216     \textcolor{keywordflow}{return} idx;}
\DoxyCodeLine{217   \}}
\DoxyCodeLine{218 }
\DoxyCodeLine{219   \mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}(\mbox{\hyperlink{classrlbox_1_1app__pointer__map}{app\_pointer\_map<typename T\_Sbx::T\_PointerType>}}* a\_map,}
\DoxyCodeLine{220               \textcolor{keyword}{typename} T\_Sbx::T\_PointerType a\_idx,}
\DoxyCodeLine{221               T a\_idx\_unsandboxed)}
\DoxyCodeLine{222     : map(a\_map)}
\DoxyCodeLine{223     , idx(a\_idx)}
\DoxyCodeLine{224     , idx\_unsandboxed(a\_idx\_unsandboxed)}
\DoxyCodeLine{225   \{\}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 \textcolor{keyword}{public}:}
\DoxyCodeLine{228   \mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}()}
\DoxyCodeLine{229     : map(\textcolor{keyword}{nullptr})}
\DoxyCodeLine{230     , idx(0)}
\DoxyCodeLine{231     , idx\_unsandboxed(0)}
\DoxyCodeLine{232   \{\}}
\DoxyCodeLine{233 }
\DoxyCodeLine{234   \mbox{\hyperlink{classrlbox_1_1app__pointer}{\string~app\_pointer}}() \{ unregister(); \}}
\DoxyCodeLine{235 }
\DoxyCodeLine{236   \mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}(\mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}\&\& other)}
\DoxyCodeLine{237   \{}
\DoxyCodeLine{238     move\_obj(std::forward<app\_pointer>(other));}
\DoxyCodeLine{239   \}}
\DoxyCodeLine{240 }
\DoxyCodeLine{241   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}\& operator=(\mbox{\hyperlink{classrlbox_1_1app__pointer}{app\_pointer}}\&\& other)}
\DoxyCodeLine{242   \{}
\DoxyCodeLine{243     \textcolor{keywordflow}{if} (\textcolor{keyword}{this} != \&other) \{}
\DoxyCodeLine{244       move\_obj(std::forward<app\_pointer>(other));}
\DoxyCodeLine{245     \}}
\DoxyCodeLine{246     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{247   \}}
\DoxyCodeLine{248 }
\DoxyCodeLine{249   \textcolor{keywordtype}{void} unregister()}
\DoxyCodeLine{250   \{}
\DoxyCodeLine{251     \textcolor{keywordflow}{if} (idx != 0) \{}
\DoxyCodeLine{252       map-\/>remove\_app\_ptr(idx);}
\DoxyCodeLine{253       map = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{254       idx = 0;}
\DoxyCodeLine{255       idx\_unsandboxed = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{256     \}}
\DoxyCodeLine{257   \}}
\DoxyCodeLine{258 }
\DoxyCodeLine{259   \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<T, T\_Sbx>}} to\_tainted()}
\DoxyCodeLine{260   \{}
\DoxyCodeLine{261     \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<T, T\_Sbx>::internal\_factory}}(}
\DoxyCodeLine{262       \textcolor{keyword}{reinterpret\_cast<}T\textcolor{keyword}{>}(idx\_unsandboxed));}
\DoxyCodeLine{263   \}}
\DoxyCodeLine{264 }
\DoxyCodeLine{268   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classrlbox_1_1app__pointer_ad1e6a6393232b3834dbd4b8eb2c729df}{is\_registered}}() const noexcept \{ \textcolor{keywordflow}{return} idx != 0; \}}
\DoxyCodeLine{269 }
\DoxyCodeLine{274   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1app__pointer_a71209edbd57c65cd36d0b5c2c03fde3f}{UNSAFE\_unverified}}() const noexcept \{ \textcolor{keywordflow}{return} get\_raw\_value(); \}}
\DoxyCodeLine{281   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1app__pointer_a1e5d8a1865acf9d29d53f0e8543e3fa2}{UNSAFE\_sandboxed}}(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{282   \{}
\DoxyCodeLine{283     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{284     \textcolor{keywordflow}{return} get\_raw\_sandbox\_value();}
\DoxyCodeLine{285   \}}
\DoxyCodeLine{286   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1app__pointer_a71209edbd57c65cd36d0b5c2c03fde3f}{UNSAFE\_unverified}}() noexcept \{ \textcolor{keywordflow}{return} get\_raw\_value(); \}}
\DoxyCodeLine{287   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1app__pointer_a1e5d8a1865acf9d29d53f0e8543e3fa2}{UNSAFE\_sandboxed}}(rlbox\_sandbox<T\_Sbx>\& sandbox) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{288   \{}
\DoxyCodeLine{289     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{290     \textcolor{keywordflow}{return} get\_raw\_sandbox\_value();}
\DoxyCodeLine{291   \}}
\DoxyCodeLine{292 \};}
\DoxyCodeLine{293 }
\DoxyCodeLine{300 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}}}
\DoxyCodeLine{301 \{}
\DoxyCodeLine{302 \textcolor{keyword}{private}:}
\DoxyCodeLine{303   \textcolor{keywordtype}{bool} val;}
\DoxyCodeLine{304 }
\DoxyCodeLine{305 \textcolor{keyword}{public}:}
\DoxyCodeLine{306   \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}}(\textcolor{keywordtype}{bool} init)}
\DoxyCodeLine{307     : val(init)}
\DoxyCodeLine{308   \{\}}
\DoxyCodeLine{309   \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}}(\textcolor{keyword}{const} \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{310   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}}\& operator=(\textcolor{keywordtype}{bool} rhs)}
\DoxyCodeLine{311   \{}
\DoxyCodeLine{312     val = rhs;}
\DoxyCodeLine{313     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{314   \}}
\DoxyCodeLine{315   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}} operator!() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}}(!val); \}}
\DoxyCodeLine{316   \textcolor{keyword}{template}<\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{317   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} unverified\_safe\_because(\textcolor{keyword}{const} \textcolor{keywordtype}{char} (\&reason)[N])\textcolor{keyword}{ const}}
\DoxyCodeLine{318 \textcolor{keyword}{  }\{}
\DoxyCodeLine{319     (void)reason; \textcolor{comment}{/* unused */}}
\DoxyCodeLine{320     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{321   \}}
\DoxyCodeLine{322   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} UNSAFE\_unverified()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{323   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} UNSAFE\_unverified() \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{324   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe() \{ \textcolor{keywordflow}{return} UNSAFE\_unverified(); \}}
\DoxyCodeLine{325   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} UNSAFE\_unverified(); \}}
\DoxyCodeLine{326 }
\DoxyCodeLine{327   \textcolor{comment}{// Add a template parameter to make sure the assert only fires when called}}
\DoxyCodeLine{328   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T=\textcolor{keywordtype}{void}>}
\DoxyCodeLine{329   \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} copy\_and\_verify(...)\textcolor{keyword}{ const}}
\DoxyCodeLine{330 \textcolor{keyword}{  }\{}
\DoxyCodeLine{331     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{332       detail::true\_v<T>,}
\DoxyCodeLine{333       \textcolor{stringliteral}{"{}You can't call copy\_and\_verify on this value, as this is a result of a "{}}}
\DoxyCodeLine{334       \textcolor{stringliteral}{"{}comparison with memory accessible by the sandbox. \(\backslash\)n"{}}}
\DoxyCodeLine{335       \textcolor{stringliteral}{"{}The sandbox could unexpectedly change the value leading to "{}}}
\DoxyCodeLine{336       \textcolor{stringliteral}{"{}time-\/of-\/check-\/time-\/of-\/use attacks. \(\backslash\)n"{}}}
\DoxyCodeLine{337       \textcolor{stringliteral}{"{}You can avoid this by making a local copy of the data."{}}}
\DoxyCodeLine{338       \textcolor{stringliteral}{"{}For example, if your original code, looked like \(\backslash\)n"{}}}
\DoxyCodeLine{339       \textcolor{stringliteral}{"{}if ((tainted\_ptr-\/>member == 5).copy\_and\_verify(...)) \{ ... \} \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{340       \textcolor{stringliteral}{"{}Change this to \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{341       \textcolor{stringliteral}{"{}tainted<int> val = tainted\_ptr-\/>member\(\backslash\)n"{}}}
\DoxyCodeLine{342       \textcolor{stringliteral}{"{}if ((val == 5).copy\_and\_verify(...)) \{ ... \} \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{343       \textcolor{stringliteral}{"{}tainted<int, T\_Sbx> foo(rlbox\_sandbox<T\_Sbx>\& sandbox) \{...\} \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{344       \textcolor{stringliteral}{"{}Alternately, if you are sure your code is safe you can use the "{}}}
\DoxyCodeLine{345       \textcolor{stringliteral}{"{}unverified\_safe\_because API to remove tainting\(\backslash\)n"{}});}
\DoxyCodeLine{346 }
\DoxyCodeLine{347     \textcolor{comment}{// this is never executed, but we need it for the function to type-\/check}}
\DoxyCodeLine{348     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{349   \}}
\DoxyCodeLine{350 \};}
\DoxyCodeLine{351 }
\DoxyCodeLine{358 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1tainted__int__hint}{tainted\_int\_hint}}}
\DoxyCodeLine{359 \{}
\DoxyCodeLine{360 \textcolor{keyword}{private}:}
\DoxyCodeLine{361   \textcolor{keywordtype}{int} val;}
\DoxyCodeLine{362 }
\DoxyCodeLine{363 \textcolor{keyword}{public}:}
\DoxyCodeLine{364   \mbox{\hyperlink{classrlbox_1_1tainted__int__hint}{tainted\_int\_hint}}(\textcolor{keywordtype}{int} init)}
\DoxyCodeLine{365     : val(init)}
\DoxyCodeLine{366   \{\}}
\DoxyCodeLine{367   \mbox{\hyperlink{classrlbox_1_1tainted__int__hint}{tainted\_int\_hint}}(\textcolor{keyword}{const} \mbox{\hyperlink{classrlbox_1_1tainted__int__hint}{tainted\_int\_hint}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{368   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted__int__hint}{tainted\_int\_hint}}\& operator=(\textcolor{keywordtype}{int} rhs)}
\DoxyCodeLine{369   \{}
\DoxyCodeLine{370     val = rhs;}
\DoxyCodeLine{371     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{372   \}}
\DoxyCodeLine{373   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}} operator!() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__boolean__hint}{tainted\_boolean\_hint}}(!val); \}}
\DoxyCodeLine{374   \textcolor{keyword}{template}<\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{375   \textcolor{keyword}{inline} \textcolor{keywordtype}{int} unverified\_safe\_because(\textcolor{keyword}{const} \textcolor{keywordtype}{char} (\&reason)[N])\textcolor{keyword}{ const}}
\DoxyCodeLine{376 \textcolor{keyword}{  }\{}
\DoxyCodeLine{377     (void)reason; \textcolor{comment}{/* unused */}}
\DoxyCodeLine{378     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{379   \}}
\DoxyCodeLine{380   \textcolor{keyword}{inline} \textcolor{keywordtype}{int} UNSAFE\_unverified()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{381   \textcolor{keyword}{inline} \textcolor{keywordtype}{int} UNSAFE\_unverified() \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{382   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe() \{ \textcolor{keywordflow}{return} UNSAFE\_unverified(); \}}
\DoxyCodeLine{383   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} UNSAFE\_unverified(); \}}
\DoxyCodeLine{384 }
\DoxyCodeLine{385   \textcolor{comment}{// Add a template parameter to make sure the assert only fires when called}}
\DoxyCodeLine{386   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T=\textcolor{keywordtype}{void}>}
\DoxyCodeLine{387   \textcolor{keyword}{inline} \textcolor{keywordtype}{int} copy\_and\_verify(...)\textcolor{keyword}{ const}}
\DoxyCodeLine{388 \textcolor{keyword}{  }\{}
\DoxyCodeLine{389     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{390       detail::true\_v<T>,}
\DoxyCodeLine{391       \textcolor{stringliteral}{"{}You can't call copy\_and\_verify on this value, as this is a result of a "{}}}
\DoxyCodeLine{392       \textcolor{stringliteral}{"{}comparison with memory accessible by the sandbox. \(\backslash\)n"{}}}
\DoxyCodeLine{393       \textcolor{stringliteral}{"{}The sandbox could unexpectedly change the value leading to "{}}}
\DoxyCodeLine{394       \textcolor{stringliteral}{"{}time-\/of-\/check-\/time-\/of-\/use attacks. \(\backslash\)n"{}}}
\DoxyCodeLine{395       \textcolor{stringliteral}{"{}You can avoid this by making a local copy of the data."{}}}
\DoxyCodeLine{396       \textcolor{stringliteral}{"{}For example, if your original code, looked like \(\backslash\)n"{}}}
\DoxyCodeLine{397       \textcolor{stringliteral}{"{}if ((tainted\_ptr-\/>member == 5).copy\_and\_verify(...)) \{ ... \} \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{398       \textcolor{stringliteral}{"{}Change this to \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{399       \textcolor{stringliteral}{"{}tainted<int> val = tainted\_ptr-\/>member\(\backslash\)n"{}}}
\DoxyCodeLine{400       \textcolor{stringliteral}{"{}if ((val == 5).copy\_and\_verify(...)) \{ ... \} \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{401       \textcolor{stringliteral}{"{}tainted<int, T\_Sbx> foo(rlbox\_sandbox<T\_Sbx>\& sandbox) \{...\} \(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{402       \textcolor{stringliteral}{"{}Alternately, if you are sure your code is safe you can use the "{}}}
\DoxyCodeLine{403       \textcolor{stringliteral}{"{}unverified\_safe\_because API to remove tainting\(\backslash\)n"{}});}
\DoxyCodeLine{404 }
\DoxyCodeLine{405     \textcolor{comment}{// this is never executed, but we need it for the function to type-\/check}}
\DoxyCodeLine{406     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{407   \}}
\DoxyCodeLine{408 \};}
\DoxyCodeLine{409 }
\DoxyCodeLine{410 \}}

\end{DoxyCode}
