\hypertarget{rlbox_8hpp_source}{}\doxysection{rlbox.\+hpp}
\label{rlbox_8hpp_source}\index{/home/d/hack/rlbox\_sandboxing\_api/code/include/rlbox.hpp@{/home/d/hack/rlbox\_sandboxing\_api/code/include/rlbox.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 }
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}rlbox\_app\_pointer.hpp"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}rlbox\_conversion.hpp"{}}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}rlbox\_helpers.hpp"{}}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include "{}rlbox\_policy\_types.hpp"{}}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}rlbox\_range.hpp"{}}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}rlbox\_sandbox.hpp"{}}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include "{}rlbox\_stdlib.hpp"{}}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}rlbox\_struct\_support.hpp"{}}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}rlbox\_type\_traits.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}rlbox\_types.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}rlbox\_unwrap.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}rlbox\_wrapper\_traits.hpp"{}}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{namespace }rlbox \{}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{keyword}{template}<\textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}> \textcolor{keyword}{typename} T\_Wrap,}
\DoxyCodeLine{25          \textcolor{keyword}{typename} T,}
\DoxyCodeLine{26          \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{27 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{tainted\_base\_impl}}}
\DoxyCodeLine{28 \{}
\DoxyCodeLine{29   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{30   KEEP\_CAST\_FRIENDLY}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{public}:}
\DoxyCodeLine{33   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& impl() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T\_Wrap<T, T\_Sbx>*\textcolor{keyword}{>}(\textcolor{keyword}{this}); \}}
\DoxyCodeLine{34   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& impl()\textcolor{keyword}{ const}}
\DoxyCodeLine{35 \textcolor{keyword}{  }\{}
\DoxyCodeLine{36     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }T\_Wrap<T, T\_Sbx>*\textcolor{keyword}{>}(\textcolor{keyword}{this});}
\DoxyCodeLine{37   \}}
\DoxyCodeLine{38 }
\DoxyCodeLine{43   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}() \{ \textcolor{keywordflow}{return} impl().get\_raw\_value(); \}}
\DoxyCodeLine{44   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} impl().get\_raw\_value(); \}}
\DoxyCodeLine{54   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ae2c69129cbb9344e7d2623129f031214}{UNSAFE\_sandboxed}}(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox)}
\DoxyCodeLine{55   \{}
\DoxyCodeLine{56     \textcolor{keywordflow}{return} impl().get\_raw\_sandbox\_value(sandbox);}
\DoxyCodeLine{57   \}}
\DoxyCodeLine{58   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ae2c69129cbb9344e7d2623129f031214}{UNSAFE\_sandboxed}}(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox)\textcolor{keyword}{ const}}
\DoxyCodeLine{59 \textcolor{keyword}{  }\{}
\DoxyCodeLine{60     \textcolor{keywordflow}{return} impl().get\_raw\_sandbox\_value(sandbox);}
\DoxyCodeLine{61   \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{69   \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ac7d2f71a8fc72b922bfa1260d4a7ac94}{rlbox\_detail\_member\_and\_const}}(}
\DoxyCodeLine{70     template<size\_t N>}
\DoxyCodeLine{71     \textcolor{keyword}{inline} \textcolor{keyword}{auto} unverified\_safe\_because(\textcolor{keyword}{const} \textcolor{keywordtype}{char} (\&reason)[N]),}
\DoxyCodeLine{72     \{}
\DoxyCodeLine{73       RLBOX\_UNUSED(reason);}
\DoxyCodeLine{74       \textcolor{keyword}{static\_assert}(!std::is\_pointer\_v<T>,}
\DoxyCodeLine{75                     \textcolor{stringliteral}{"{}unverified\_safe\_because does not support pointers. Use "{}}}
\DoxyCodeLine{76                     \textcolor{stringliteral}{"{}unverified\_safe\_pointer\_because."{}});}
\DoxyCodeLine{77       \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}();}
\DoxyCodeLine{78     \});}
\DoxyCodeLine{79 }
\DoxyCodeLine{80   \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ac7d2f71a8fc72b922bfa1260d4a7ac94}{rlbox\_detail\_member\_and\_const}}(}
\DoxyCodeLine{81     template<size\_t N>}
\DoxyCodeLine{82     \textcolor{keyword}{inline} \textcolor{keyword}{auto} unverified\_safe\_pointer\_because(\textcolor{keywordtype}{size\_t} count,}
\DoxyCodeLine{83                                                 \textcolor{keyword}{const} \textcolor{keywordtype}{char} (\&reason)[N]),}
\DoxyCodeLine{84     \{}
\DoxyCodeLine{85       RLBOX\_UNUSED(reason);}
\DoxyCodeLine{86 }
\DoxyCodeLine{87       \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>, \textcolor{stringliteral}{"{}Expected pointer type"{}});}
\DoxyCodeLine{88       \textcolor{keyword}{using} T\_Pointed = std::remove\_pointer\_t<T>;}
\DoxyCodeLine{89       if\_constexpr\_named(cond1, std::is\_pointer\_v<T\_Pointed>)}
\DoxyCodeLine{90       \{}
\DoxyCodeLine{91         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{92           cond1,}
\DoxyCodeLine{93           \textcolor{stringliteral}{"{}There is no way to use unverified\_safe\_pointer\_because for "{}}}
\DoxyCodeLine{94           \textcolor{stringliteral}{"{}'pointers to pointers' safely. Use copy\_and\_verify instead."{}});}
\DoxyCodeLine{95         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{96       \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98       \textcolor{keyword}{auto} ret = \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}();}
\DoxyCodeLine{99       \textcolor{keywordflow}{if} (ret != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{100         \textcolor{keywordtype}{size\_t} bytes = \textcolor{keyword}{sizeof}(T) * count;}
\DoxyCodeLine{101         detail::check\_range\_doesnt\_cross\_app\_sbx\_boundary<T\_Sbx>(ret, bytes);}
\DoxyCodeLine{102       \}}
\DoxyCodeLine{103       \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{104     \});}
\DoxyCodeLine{105 }
\DoxyCodeLine{106   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}(); \}}
\DoxyCodeLine{107   \textcolor{keyword}{inline} \textcolor{keyword}{auto} INTERNAL\_unverified\_safe()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a01acab6b4bd8137afa03cf4b2678844f}{UNSAFE\_unverified}}(); \}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{preprocessor}{\#define BinaryOpValAndPtr(opSymbol)                                            \(\backslash\)}}
\DoxyCodeLine{110 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{111 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs)                    \(\backslash\)}}
\DoxyCodeLine{112 \textcolor{preprocessor}{    const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}}
\DoxyCodeLine{113 \textcolor{preprocessor}{                            detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}}
\DoxyCodeLine{114 \textcolor{preprocessor}{                   T\_Sbx>                                                      \(\backslash\)}}
\DoxyCodeLine{115 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{116 \textcolor{preprocessor}{    static\_assert(detail::is\_basic\_type\_v<T>,                                  \(\backslash\)}}
\DoxyCodeLine{117 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol                                        \(\backslash\)}
\DoxyCodeLine{118                   "{} only supported for primitive and pointer types"{});          \(\backslash\)}
\DoxyCodeLine{119                                                                                \(\backslash\)}
\DoxyCodeLine{120     auto raw\_rhs = detail::unwrap\_value(rhs);                                  \(\backslash\)}
\DoxyCodeLine{121                                                                                \(\backslash\)}
\DoxyCodeLine{122     if constexpr (std::is\_pointer\_v<T>) \{                                      \(\backslash\)}
\DoxyCodeLine{123       static\_assert(std::is\_integral\_v<decltype(raw\_rhs)>,                     \(\backslash\)}
\DoxyCodeLine{124                     "{}Can only operate on numeric types"{});                      \(\backslash\)}
\DoxyCodeLine{125       auto ptr = impl().get\_raw\_value();                                       \(\backslash\)}
\DoxyCodeLine{126       detail::dynamic\_check(ptr != nullptr,                                    \(\backslash\)}
\DoxyCodeLine{127                             "{}Pointer arithmetic on a null pointer"{});           \(\backslash\)}
\DoxyCodeLine{128       \textcolor{comment}{/* increment the target by size of the data structure */}\textcolor{preprocessor}{                 \(\backslash\)}}
\DoxyCodeLine{129 \textcolor{preprocessor}{      auto target =                                                            \(\backslash\)}}
\DoxyCodeLine{130 \textcolor{preprocessor}{        reinterpret\_cast<uintptr\_t>(ptr) opSymbol raw\_rhs * sizeof(*impl());   \(\backslash\)}}
\DoxyCodeLine{131 \textcolor{preprocessor}{      auto no\_overflow = rlbox\_sandbox<T\_Sbx>::is\_in\_same\_sandbox(             \(\backslash\)}}
\DoxyCodeLine{132 \textcolor{preprocessor}{        reinterpret\_cast<const void*>(ptr),                                    \(\backslash\)}}
\DoxyCodeLine{133 \textcolor{preprocessor}{        reinterpret\_cast<const void*>(target));                                \(\backslash\)}}
\DoxyCodeLine{134 \textcolor{preprocessor}{      detail::dynamic\_check(                                                   \(\backslash\)}}
\DoxyCodeLine{135 \textcolor{preprocessor}{        no\_overflow,                                                           \(\backslash\)}}
\DoxyCodeLine{136 \textcolor{preprocessor}{        "{}Pointer arithmetic overflowed a pointer beyond sandbox memory"{}});      \(\backslash\)}
\DoxyCodeLine{137                                                                                \(\backslash\)}
\DoxyCodeLine{138       return tainted<T, T\_Sbx>::internal\_factory(reinterpret\_cast<T>(target)); \(\backslash\)}
\DoxyCodeLine{139     \} else \{                                                                   \(\backslash\)}
\DoxyCodeLine{140       auto raw = impl().get\_raw\_value();                                       \(\backslash\)}
\DoxyCodeLine{141       auto ret = raw opSymbol raw\_rhs;                                         \(\backslash\)}
\DoxyCodeLine{142       using T\_Ret = decltype(ret);                                             \(\backslash\)}
\DoxyCodeLine{143       return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                     \(\backslash\)}
\DoxyCodeLine{144     \}                                                                          \(\backslash\)}
\DoxyCodeLine{145   \}                                                                            \(\backslash\)}
\DoxyCodeLine{146   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{147 }
\DoxyCodeLine{148   BinaryOpValAndPtr(+);}
\DoxyCodeLine{149   BinaryOpValAndPtr(-\/);}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 \textcolor{preprocessor}{\#undef BinaryOpValAndPtr}}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{preprocessor}{\#define BinaryOp(opSymbol)                                                     \(\backslash\)}}
\DoxyCodeLine{154 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{155 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs)                    \(\backslash\)}}
\DoxyCodeLine{156 \textcolor{preprocessor}{    const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}}
\DoxyCodeLine{157 \textcolor{preprocessor}{                            detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}}
\DoxyCodeLine{158 \textcolor{preprocessor}{                   T\_Sbx>                                                      \(\backslash\)}}
\DoxyCodeLine{159 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{160 \textcolor{preprocessor}{    static\_assert(detail::is\_fundamental\_or\_enum\_v<T>,                         \(\backslash\)}}
\DoxyCodeLine{161 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol                                        \(\backslash\)}
\DoxyCodeLine{162                   "{} only supported for primitive  types"{});                     \(\backslash\)}
\DoxyCodeLine{163                                                                                \(\backslash\)}
\DoxyCodeLine{164     auto raw = impl().get\_raw\_value();                                         \(\backslash\)}
\DoxyCodeLine{165     auto raw\_rhs = detail::unwrap\_value(rhs);                                  \(\backslash\)}
\DoxyCodeLine{166     static\_assert(std::is\_integral\_v<decltype(raw\_rhs)>,                       \(\backslash\)}
\DoxyCodeLine{167                   "{}Can only operate on numeric types"{});                        \(\backslash\)}
\DoxyCodeLine{168                                                                                \(\backslash\)}
\DoxyCodeLine{169     auto ret = raw opSymbol raw\_rhs;                                           \(\backslash\)}
\DoxyCodeLine{170     using T\_Ret = decltype(ret);                                               \(\backslash\)}
\DoxyCodeLine{171     return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                       \(\backslash\)}
\DoxyCodeLine{172   \}                                                                            \(\backslash\)}
\DoxyCodeLine{173   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{174 }
\DoxyCodeLine{175   BinaryOp(*);}
\DoxyCodeLine{176   BinaryOp(/);}
\DoxyCodeLine{177   BinaryOp(\%);}
\DoxyCodeLine{178   BinaryOp(\string^);}
\DoxyCodeLine{179   BinaryOp(\&);}
\DoxyCodeLine{180   BinaryOp(|);}
\DoxyCodeLine{181   BinaryOp(<<);}
\DoxyCodeLine{182   BinaryOp(>>);}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{preprocessor}{\#undef BinaryOp}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \textcolor{preprocessor}{\#define CompoundAssignmentOp(opSymbol)                                         \(\backslash\)}}
\DoxyCodeLine{187 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{188 \textcolor{preprocessor}{  inline constexpr T\_Wrap<T, T\_Sbx>\& operator opSymbol\#\#=(const T\_Rhs\& rhs)    \(\backslash\)}}
\DoxyCodeLine{189 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{190 \textcolor{preprocessor}{    auto\& this\_ref = impl();                                                   \(\backslash\)}}
\DoxyCodeLine{191 \textcolor{preprocessor}{    this\_ref = this\_ref opSymbol rhs;                                          \(\backslash\)}}
\DoxyCodeLine{192 \textcolor{preprocessor}{    return this\_ref;                                                           \(\backslash\)}}
\DoxyCodeLine{193 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{194 \textcolor{preprocessor}{  RLBOX\_REQUIRE\_SEMI\_COLON}}
\DoxyCodeLine{195 }
\DoxyCodeLine{196   CompoundAssignmentOp(+);}
\DoxyCodeLine{197   CompoundAssignmentOp(-\/);}
\DoxyCodeLine{198   CompoundAssignmentOp(*);}
\DoxyCodeLine{199   CompoundAssignmentOp(/);}
\DoxyCodeLine{200   CompoundAssignmentOp(\%);}
\DoxyCodeLine{201   CompoundAssignmentOp(\string^);}
\DoxyCodeLine{202   CompoundAssignmentOp(\&);}
\DoxyCodeLine{203   CompoundAssignmentOp(|);}
\DoxyCodeLine{204   CompoundAssignmentOp(<<);}
\DoxyCodeLine{205   CompoundAssignmentOp(>>);}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{preprocessor}{\#undef CompoundAssignmentOp}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{preprocessor}{\#define PreIncDecOps(opSymbol)                                                 \(\backslash\)}}
\DoxyCodeLine{210 \textcolor{preprocessor}{  inline constexpr T\_Wrap<T, T\_Sbx>\& operator opSymbol\#\#opSymbol()             \(\backslash\)}}
\DoxyCodeLine{211 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{212 \textcolor{preprocessor}{    auto\& this\_ref = impl();                                                   \(\backslash\)}}
\DoxyCodeLine{213 \textcolor{preprocessor}{    this\_ref = this\_ref opSymbol 1;                                            \(\backslash\)}}
\DoxyCodeLine{214 \textcolor{preprocessor}{    return this\_ref;                                                           \(\backslash\)}}
\DoxyCodeLine{215 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{216 \textcolor{preprocessor}{  RLBOX\_REQUIRE\_SEMI\_COLON}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218   PreIncDecOps(+);}
\DoxyCodeLine{219   PreIncDecOps(-\/);}
\DoxyCodeLine{220 }
\DoxyCodeLine{221 \textcolor{preprocessor}{\#undef PreIncDecOps}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 \textcolor{preprocessor}{\#define PostIncDecOps(opSymbol)                                                \(\backslash\)}}
\DoxyCodeLine{224 \textcolor{preprocessor}{  inline constexpr T\_Wrap<T, T\_Sbx> operator opSymbol\#\#opSymbol(int)           \(\backslash\)}}
\DoxyCodeLine{225 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{226 \textcolor{preprocessor}{    tainted<T, T\_Sbx> ret = impl();                                            \(\backslash\)}}
\DoxyCodeLine{227 \textcolor{preprocessor}{    operator++();                                                              \(\backslash\)}}
\DoxyCodeLine{228 \textcolor{preprocessor}{    return ret;                                                                \(\backslash\)}}
\DoxyCodeLine{229 \textcolor{preprocessor}{  \}                                                                            \(\backslash\)}}
\DoxyCodeLine{230 \textcolor{preprocessor}{  RLBOX\_REQUIRE\_SEMI\_COLON}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232   PostIncDecOps(+);}
\DoxyCodeLine{233   PostIncDecOps(-\/);}
\DoxyCodeLine{234 }
\DoxyCodeLine{235 \textcolor{preprocessor}{\#undef PostIncDecOps}}
\DoxyCodeLine{236 }
\DoxyCodeLine{237 \textcolor{preprocessor}{\#define BooleanBinaryOp(opSymbol)                                              \(\backslash\)}}
\DoxyCodeLine{238 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{239 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs)                    \(\backslash\)}}
\DoxyCodeLine{240 \textcolor{preprocessor}{    const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}}
\DoxyCodeLine{241 \textcolor{preprocessor}{                            detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}}
\DoxyCodeLine{242 \textcolor{preprocessor}{                   T\_Sbx>                                                      \(\backslash\)}}
\DoxyCodeLine{243 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{244 \textcolor{preprocessor}{    static\_assert(detail::is\_fundamental\_or\_enum\_v<T>,                         \(\backslash\)}}
\DoxyCodeLine{245 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol                                        \(\backslash\)}
\DoxyCodeLine{246                   "{} only supported for primitive  types"{});                     \(\backslash\)}
\DoxyCodeLine{247                                                                                \(\backslash\)}
\DoxyCodeLine{248     auto raw = impl().get\_raw\_value();                                         \(\backslash\)}
\DoxyCodeLine{249     auto raw\_rhs = detail::unwrap\_value(rhs);                                  \(\backslash\)}
\DoxyCodeLine{250     static\_assert(std::is\_integral\_v<decltype(raw\_rhs)>,                       \(\backslash\)}
\DoxyCodeLine{251                   "{}Can only operate on numeric types"{});                        \(\backslash\)}
\DoxyCodeLine{252                                                                                \(\backslash\)}
\DoxyCodeLine{253     auto ret = raw opSymbol raw\_rhs;                                           \(\backslash\)}
\DoxyCodeLine{254     using T\_Ret = decltype(ret);                                               \(\backslash\)}
\DoxyCodeLine{255     return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                       \(\backslash\)}
\DoxyCodeLine{256   \}                                                                            \(\backslash\)}
\DoxyCodeLine{257                                                                                \(\backslash\)}
\DoxyCodeLine{258   template<typename T\_Rhs>                                                     \(\backslash\)}
\DoxyCodeLine{259   inline constexpr auto operator opSymbol(const T\_Rhs\&\&)                       \(\backslash\)}
\DoxyCodeLine{260     const-\/>tainted<decltype(std::declval<T>() opSymbol std::declval<           \(\backslash\)}
\DoxyCodeLine{261                             detail::rlbox\_remove\_wrapper\_t<T\_Rhs>>()),         \(\backslash\)}
\DoxyCodeLine{262                    T\_Sbx>                                                      \(\backslash\)}
\DoxyCodeLine{263   \{                                                                            \(\backslash\)}
\DoxyCodeLine{264     rlbox\_detail\_static\_fail\_because(                                          \(\backslash\)}
\DoxyCodeLine{265       detail::true\_v<T\_Rhs>,                                                   \(\backslash\)}
\DoxyCodeLine{266       "{}C++ does not permit safe overloading of \&\& and || operations as this "{}  \(\backslash\)}
\DoxyCodeLine{267       "{}affects the short circuiting behaviour of these operations. RLBox "{}     \(\backslash\)}
\DoxyCodeLine{268       "{}does let you use \&\& and || with tainted in limited situations -\/ when "{}  \(\backslash\)}
\DoxyCodeLine{269       "{}all arguments starting from the second are local variables. It does "{}   \(\backslash\)}
\DoxyCodeLine{270       "{}not allow it if arguments starting from the second  are expressions.\(\backslash\)n"{} \(\backslash\)}
\DoxyCodeLine{271       "{}For example the following is not allowed\(\backslash\)n"{}                             \(\backslash\)}
\DoxyCodeLine{272       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{273       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{274       "{}auto r = a \&\& true \&\& sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}      \(\backslash\)}
\DoxyCodeLine{275       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{276       "{}However the following would be allowed\(\backslash\)n"{}                               \(\backslash\)}
\DoxyCodeLine{277       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{278       "{}auto b = true\(\backslash\)n"{}                                                        \(\backslash\)}
\DoxyCodeLine{279       "{}auto c = sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}                   \(\backslash\)}
\DoxyCodeLine{280       "{}auto r = a \&\& b \&\& c;\(\backslash\)n"{}                                                \(\backslash\)}
\DoxyCodeLine{281       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{282       "{}Note that these 2 programs are not identical. The first program may "{}   \(\backslash\)}
\DoxyCodeLine{283       "{}or may not call getBool, while second program always calls getBool"{});   \(\backslash\)}
\DoxyCodeLine{284     return tainted<bool, T\_Sbx>(false);                                        \(\backslash\)}
\DoxyCodeLine{285   \}                                                                            \(\backslash\)}
\DoxyCodeLine{286   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{287 }
\DoxyCodeLine{288   BooleanBinaryOp(\&\&);}
\DoxyCodeLine{289   BooleanBinaryOp(||);}
\DoxyCodeLine{290 }
\DoxyCodeLine{291 \textcolor{preprocessor}{\#undef BooleanBinaryOp}}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{preprocessor}{\#define UnaryOp(opSymbol)                                                      \(\backslash\)}}
\DoxyCodeLine{294 \textcolor{preprocessor}{  inline auto operator opSymbol()                                              \(\backslash\)}}
\DoxyCodeLine{295 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{296 \textcolor{preprocessor}{    static\_assert(detail::is\_fundamental\_or\_enum\_v<T>,                         \(\backslash\)}}
\DoxyCodeLine{297 \textcolor{preprocessor}{                  "{}Operator "{}} \#opSymbol "{} only supported for primitive"{});      \(\backslash\)}
\DoxyCodeLine{298                                                                                \(\backslash\)}
\DoxyCodeLine{299     auto raw = impl().get\_raw\_value();                                         \(\backslash\)}
\DoxyCodeLine{300     auto ret = opSymbol raw;                                                   \(\backslash\)}
\DoxyCodeLine{301     using T\_Ret = decltype(ret);                                               \(\backslash\)}
\DoxyCodeLine{302     return tainted<T\_Ret, T\_Sbx>::internal\_factory(ret);                       \(\backslash\)}
\DoxyCodeLine{303   \}                                                                            \(\backslash\)}
\DoxyCodeLine{304   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{305 }
\DoxyCodeLine{306   UnaryOp(-\/);}
\DoxyCodeLine{307   UnaryOp(\string~);}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{preprocessor}{\#undef UnaryOp}}
\DoxyCodeLine{310 }
\DoxyCodeLine{321 \textcolor{preprocessor}{\#define CompareOp(opSymbol, permit\_pointers)                                   \(\backslash\)}}
\DoxyCodeLine{322 \textcolor{preprocessor}{  template<typename T\_Rhs>                                                     \(\backslash\)}}
\DoxyCodeLine{323 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(const T\_Rhs\& rhs) const              \(\backslash\)}}
\DoxyCodeLine{324 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{325 \textcolor{preprocessor}{    using T\_RhsNoQ = detail::remove\_cv\_ref\_t<T\_Rhs>;                           \(\backslash\)}}
\DoxyCodeLine{326 \textcolor{preprocessor}{    constexpr bool check\_rhs\_hint =                                            \(\backslash\)}}
\DoxyCodeLine{327 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_volatile\_v<T\_RhsNoQ> ||                         \(\backslash\)}}
\DoxyCodeLine{328 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_RhsNoQ>;                       \(\backslash\)}}
\DoxyCodeLine{329 \textcolor{preprocessor}{    constexpr bool check\_lhs\_hint =                                            \(\backslash\)}}
\DoxyCodeLine{330 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_volatile\_v<T\_Wrap<T, T\_Sbx>>;                   \(\backslash\)}}
\DoxyCodeLine{331 \textcolor{preprocessor}{    constexpr bool is\_hint = check\_lhs\_hint || check\_rhs\_hint;                 \(\backslash\)}}
\DoxyCodeLine{332 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{333 \textcolor{preprocessor}{    constexpr bool is\_unwrapped =                                              \(\backslash\)}}
\DoxyCodeLine{334 \textcolor{preprocessor}{      detail::rlbox\_is\_tainted\_v<T\_Wrap<T, T\_Sbx>> \&\&                          \(\backslash\)}}
\DoxyCodeLine{335 \textcolor{preprocessor}{      std::is\_null\_pointer\_v<T\_RhsNoQ>;                                        \(\backslash\)}}
\DoxyCodeLine{336 \textcolor{preprocessor}{                                                                               \(\backslash\)}}
\DoxyCodeLine{337 \textcolor{preprocessor}{    }\textcolor{comment}{/* Sanity check -\/ can't be a hint and unwrapped */}\textcolor{preprocessor}{                         \(\backslash\)}}
\DoxyCodeLine{338 \textcolor{preprocessor}{    static\_assert(is\_hint ? !is\_unwrapped : true,                              \(\backslash\)}}
\DoxyCodeLine{339 \textcolor{preprocessor}{                  "{}Internal error: Could not deduce type for comparison. "{}}     \(\backslash\)}
\DoxyCodeLine{340                   "{}Please file a bug."{});                                       \(\backslash\)}
\DoxyCodeLine{341                                                                                \(\backslash\)}
\DoxyCodeLine{342     if constexpr (!permit\_pointers \&\& std::is\_pointer\_v<T>) \{                  \(\backslash\)}
\DoxyCodeLine{343       rlbox\_detail\_static\_fail\_because(                                        \(\backslash\)}
\DoxyCodeLine{344         std::is\_pointer\_v<T>,                                                  \(\backslash\)}
\DoxyCodeLine{345         "{}Only == and != comparisons are allowed for pointers"{});                \(\backslash\)}
\DoxyCodeLine{346     \}                                                                          \(\backslash\)}
\DoxyCodeLine{347                                                                                \(\backslash\)}
\DoxyCodeLine{348     bool ret = (impl().get\_raw\_value() opSymbol detail::unwrap\_value(rhs));    \(\backslash\)}
\DoxyCodeLine{349                                                                                \(\backslash\)}
\DoxyCodeLine{350     if constexpr (is\_hint) \{                                                   \(\backslash\)}
\DoxyCodeLine{351       return tainted\_boolean\_hint(ret);                                        \(\backslash\)}
\DoxyCodeLine{352     \} else if constexpr (is\_unwrapped) \{                                       \(\backslash\)}
\DoxyCodeLine{353       return ret;                                                              \(\backslash\)}
\DoxyCodeLine{354     \} else \{                                                                   \(\backslash\)}
\DoxyCodeLine{355       return tainted<bool, T\_Sbx>(ret);                                        \(\backslash\)}
\DoxyCodeLine{356     \}                                                                          \(\backslash\)}
\DoxyCodeLine{357   \}                                                                            \(\backslash\)}
\DoxyCodeLine{358   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{359 }
\DoxyCodeLine{360   CompareOp(==, \textcolor{keyword}{true} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{361   CompareOp(!=, \textcolor{keyword}{true} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{362   CompareOp(<, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{363   CompareOp(<=, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{364   CompareOp(>, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{365   CompareOp(>=, \textcolor{keyword}{false} \textcolor{comment}{/* permit\_pointers */});}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{preprocessor}{\#undef CompareOp}}
\DoxyCodeLine{368 }
\DoxyCodeLine{369 \textcolor{keyword}{private}:}
\DoxyCodeLine{370   \textcolor{keyword}{using} T\_OpSubscriptArrRet = std::conditional\_t<}
\DoxyCodeLine{371     std::is\_pointer\_v<T>,}
\DoxyCodeLine{372     tainted\_volatile<detail::dereference\_result\_t<T>, T\_Sbx>, \textcolor{comment}{// is\_pointer}}
\DoxyCodeLine{373     T\_Wrap<detail::dereference\_result\_t<T>, T\_Sbx>            \textcolor{comment}{// is\_array}}
\DoxyCodeLine{374     >;}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 \textcolor{keyword}{public}:}
\DoxyCodeLine{377   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{378   \textcolor{keyword}{inline} \textcolor{keyword}{const} T\_OpSubscriptArrRet\& operator[](T\_Rhs\&\& rhs)\textcolor{keyword}{ const}}
\DoxyCodeLine{379 \textcolor{keyword}{  }\{}
\DoxyCodeLine{380     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T> || detail::is\_c\_or\_std\_array\_v<T>,}
\DoxyCodeLine{381                   \textcolor{stringliteral}{"{}Operator [] supports pointers and arrays only"{}});}
\DoxyCodeLine{382 }
\DoxyCodeLine{383     \textcolor{keyword}{auto} raw\_rhs = detail::unwrap\_value(rhs);}
\DoxyCodeLine{384     \textcolor{keyword}{static\_assert}(std::is\_integral\_v<\textcolor{keyword}{decltype}(raw\_rhs)>,}
\DoxyCodeLine{385                   \textcolor{stringliteral}{"{}Can only index with numeric types"{}});}
\DoxyCodeLine{386 }
\DoxyCodeLine{387     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_pointer\_v<T>) \{}
\DoxyCodeLine{388       \textcolor{keyword}{auto} ptr = this-\/>impl().get\_raw\_value();}
\DoxyCodeLine{389 }
\DoxyCodeLine{390       \textcolor{comment}{// increment the target by size of the data structure}}
\DoxyCodeLine{391       \textcolor{keyword}{auto} target =}
\DoxyCodeLine{392         \textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(ptr) + raw\_rhs * \textcolor{keyword}{sizeof}(*this-\/>impl());}
\DoxyCodeLine{393       \textcolor{keyword}{auto} no\_overflow = \mbox{\hyperlink{classrlbox_1_1rlbox__sandbox_a3257ffc0e7eb6022c05a049b8b36271f}{rlbox\_sandbox<T\_Sbx>::is\_in\_same\_sandbox}}(}
\DoxyCodeLine{394         ptr, \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(target));}
\DoxyCodeLine{395       detail::dynamic\_check(}
\DoxyCodeLine{396         no\_overflow,}
\DoxyCodeLine{397         \textcolor{stringliteral}{"{}Pointer arithmetic overflowed a pointer beyond sandbox memory"{}});}
\DoxyCodeLine{398 }
\DoxyCodeLine{399       \textcolor{keyword}{auto} target\_wrap = tainted<const T, T\_Sbx>::internal\_factory(}
\DoxyCodeLine{400         \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }T\textcolor{keyword}{>}(target));}
\DoxyCodeLine{401       \textcolor{keywordflow}{return} *target\_wrap;}
\DoxyCodeLine{402     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{403       \textcolor{keyword}{using} T\_Rhs\_Unsigned = std::make\_unsigned\_t<\textcolor{keyword}{decltype}(raw\_rhs)>;}
\DoxyCodeLine{404       detail::dynamic\_check(}
\DoxyCodeLine{405         raw\_rhs >= 0 \&\& \textcolor{keyword}{static\_cast<}T\_Rhs\_Unsigned\textcolor{keyword}{>}(raw\_rhs) <}
\DoxyCodeLine{406                           std::extent\_v<detail::std\_array\_to\_c\_arr\_t<T>, 0>,}
\DoxyCodeLine{407         \textcolor{stringliteral}{"{}Static array indexing overflow"{}});}
\DoxyCodeLine{408 }
\DoxyCodeLine{409       \textcolor{keyword}{const} \textcolor{keywordtype}{void}* target\_ptr;}
\DoxyCodeLine{410       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (detail::rlbox\_is\_tainted\_v<T\_Wrap<T, T\_Sbx>>) \{}
\DoxyCodeLine{411         \textcolor{keyword}{auto}\& data\_ref = impl().get\_raw\_value\_ref();}
\DoxyCodeLine{412         target\_ptr = \&(data\_ref[raw\_rhs]);}
\DoxyCodeLine{413       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{414         \textcolor{keyword}{auto}\& data\_ref = impl().get\_sandbox\_value\_ref();}
\DoxyCodeLine{415         \textcolor{keyword}{auto} target\_ptr\_vol = \&(data\_ref[raw\_rhs]);}
\DoxyCodeLine{416         \textcolor{comment}{// target\_ptr is a volatile... remove this.}}
\DoxyCodeLine{417         \textcolor{comment}{// Safe as we will return a tainted\_volatile if this is the case}}
\DoxyCodeLine{418         target\_ptr = detail::remove\_volatile\_from\_ptr\_cast(target\_ptr\_vol);}
\DoxyCodeLine{419       \}}
\DoxyCodeLine{420 }
\DoxyCodeLine{421       \textcolor{keyword}{using} T\_Target = \textcolor{keyword}{const} T\_Wrap<detail::dereference\_result\_t<T>, T\_Sbx>;}
\DoxyCodeLine{422       \textcolor{keyword}{auto} wrapped\_target\_ptr = \textcolor{keyword}{reinterpret\_cast<}T\_Target*\textcolor{keyword}{>}(target\_ptr);}
\DoxyCodeLine{423       \textcolor{keywordflow}{return} *wrapped\_target\_ptr;}
\DoxyCodeLine{424     \}}
\DoxyCodeLine{425   \}}
\DoxyCodeLine{426 }
\DoxyCodeLine{427   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{428   \textcolor{keyword}{inline} T\_OpSubscriptArrRet\& operator[](T\_Rhs\&\& rhs)}
\DoxyCodeLine{429   \{}
\DoxyCodeLine{430     rlbox\_detail\_forward\_to\_const\_a(\textcolor{keyword}{operator}[], T\_OpSubscriptArrRet\&, rhs);}
\DoxyCodeLine{431   \}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433 \textcolor{keyword}{private}:}
\DoxyCodeLine{434   \textcolor{keyword}{using} T\_OpDerefRet = tainted\_volatile<std::remove\_pointer\_t<T>, T\_Sbx>;}
\DoxyCodeLine{435 }
\DoxyCodeLine{436 \textcolor{keyword}{public}:}
\DoxyCodeLine{437   \textcolor{keyword}{inline} T\_OpDerefRet\& operator*()\textcolor{keyword}{ const}}
\DoxyCodeLine{438 \textcolor{keyword}{  }\{}
\DoxyCodeLine{439     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>, \textcolor{stringliteral}{"{}Operator * only allowed on pointers"{}});}
\DoxyCodeLine{440     \textcolor{keyword}{auto} ret\_ptr\_const =}
\DoxyCodeLine{441       \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }T\_OpDerefRet*\textcolor{keyword}{>}(impl().get\_raw\_value());}
\DoxyCodeLine{442     \textcolor{comment}{// Safe -\/ If T\_OpDerefRet is not a const ptr, this is trivially safe}}
\DoxyCodeLine{443     \textcolor{comment}{//        If T\_OpDerefRet is a const ptr, then the const is captured}}
\DoxyCodeLine{444     \textcolor{comment}{//        inside the wrapper}}
\DoxyCodeLine{445     \textcolor{keyword}{auto} ret\_ptr = \textcolor{keyword}{const\_cast<}T\_OpDerefRet*\textcolor{keyword}{>}(ret\_ptr\_const);}
\DoxyCodeLine{446     \textcolor{keywordflow}{return} *ret\_ptr;}
\DoxyCodeLine{447   \}}
\DoxyCodeLine{448 }
\DoxyCodeLine{449   \textcolor{keyword}{inline} T\_OpDerefRet\& operator*()}
\DoxyCodeLine{450   \{}
\DoxyCodeLine{451     rlbox\_detail\_forward\_to\_const(\textcolor{keyword}{operator}*, T\_OpDerefRet\&);}
\DoxyCodeLine{452   \}}
\DoxyCodeLine{453 }
\DoxyCodeLine{454   \textcolor{comment}{// We need to implement the -\/> operator even if T is not a struct}}
\DoxyCodeLine{455   \textcolor{comment}{// So that we can support code patterns such as the below}}
\DoxyCodeLine{456   \textcolor{comment}{// tainted<T*> a;}}
\DoxyCodeLine{457   \textcolor{comment}{// a-\/>UNSAFE\_unverified();}}
\DoxyCodeLine{458   \textcolor{keyword}{inline} \textcolor{keyword}{auto} operator-\/>()\textcolor{keyword}{ const}}
\DoxyCodeLine{459 \textcolor{keyword}{  }\{}
\DoxyCodeLine{460     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{461                   \textcolor{stringliteral}{"{}Operator -\/> only supported for pointer types"{}});}
\DoxyCodeLine{462     \textcolor{keyword}{auto} ret = impl().get\_raw\_value();}
\DoxyCodeLine{463     \textcolor{keyword}{using} T\_Ret = std::remove\_pointer\_t<T>;}
\DoxyCodeLine{464     \textcolor{keyword}{using} T\_RetWrap = \textcolor{keyword}{const} tainted\_volatile<T\_Ret, T\_Sbx>;}
\DoxyCodeLine{465     \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}T\_RetWrap*\textcolor{keyword}{>}(ret);}
\DoxyCodeLine{466   \}}
\DoxyCodeLine{467 }
\DoxyCodeLine{468   \textcolor{keyword}{inline} \textcolor{keyword}{auto} operator-\/>()}
\DoxyCodeLine{469   \{}
\DoxyCodeLine{470     \textcolor{keyword}{using} T\_Ret = tainted\_volatile<std::remove\_pointer\_t<T>, T\_Sbx>*;}
\DoxyCodeLine{471     rlbox\_detail\_forward\_to\_const(operator-\/>, T\_Ret);}
\DoxyCodeLine{472   \}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474   \textcolor{keyword}{inline} \textcolor{keyword}{auto} operator!()}
\DoxyCodeLine{475   \{}
\DoxyCodeLine{476     if\_constexpr\_named(cond1, std::is\_pointer\_v<T>)}
\DoxyCodeLine{477     \{}
\DoxyCodeLine{478       \textcolor{keywordflow}{return} impl() == \textcolor{keyword}{nullptr};}
\DoxyCodeLine{479     \}}
\DoxyCodeLine{480     \textcolor{keywordflow}{else} if\_constexpr\_named(cond2, std::is\_same\_v<std::remove\_cv\_t<T>, \textcolor{keywordtype}{bool}>)}
\DoxyCodeLine{481     \{}
\DoxyCodeLine{482       \textcolor{keywordflow}{return} impl() == \textcolor{keyword}{false};}
\DoxyCodeLine{483     \}}
\DoxyCodeLine{484     \textcolor{keywordflow}{else}}
\DoxyCodeLine{485     \{}
\DoxyCodeLine{486       \textcolor{keyword}{auto} unknownCase = !(cond1 || cond2);}
\DoxyCodeLine{487       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{488         unknownCase,}
\DoxyCodeLine{489         \textcolor{stringliteral}{"{}Operator ! only permitted for pointer or boolean types. For other"{}}}
\DoxyCodeLine{490         \textcolor{stringliteral}{"{}types, unwrap the tainted value with the copy\_and\_verify API and then"{}}}
\DoxyCodeLine{491         \textcolor{stringliteral}{"{}use operator !"{}});}
\DoxyCodeLine{492     \}}
\DoxyCodeLine{493   \}}
\DoxyCodeLine{494 }
\DoxyCodeLine{502   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{503   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a701759aedd637f48cc97a0e6ada1c8a6}{copy\_and\_verify}}(T\_Func verifier)\textcolor{keyword}{ const}}
\DoxyCodeLine{504 \textcolor{keyword}{  }\{}
\DoxyCodeLine{505     \textcolor{keyword}{using} T\_Deref = std::remove\_cv\_t<std::remove\_pointer\_t<T>>;}
\DoxyCodeLine{506 }
\DoxyCodeLine{507     if\_constexpr\_named(cond1, detail::is\_fundamental\_or\_enum\_v<T>)}
\DoxyCodeLine{508     \{}
\DoxyCodeLine{509       \textcolor{keyword}{auto} val = impl().get\_raw\_value();}
\DoxyCodeLine{510       \textcolor{keywordflow}{return} verifier(val);}
\DoxyCodeLine{511     \}}
\DoxyCodeLine{512     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{513       cond2, detail::is\_one\_level\_ptr\_v<T> \&\& !std::is\_class\_v<T\_Deref>)}
\DoxyCodeLine{514     \{}
\DoxyCodeLine{515       \textcolor{comment}{// Some paths don't use the verifier}}
\DoxyCodeLine{516       RLBOX\_UNUSED(verifier);}
\DoxyCodeLine{517 }
\DoxyCodeLine{518       if\_constexpr\_named(subcond1, std::is\_void\_v<T\_Deref>)}
\DoxyCodeLine{519       \{}
\DoxyCodeLine{520         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{521           subcond1,}
\DoxyCodeLine{522           \textcolor{stringliteral}{"{}copy\_and\_verify not recommended for void* as it could lead to some "{}}}
\DoxyCodeLine{523           \textcolor{stringliteral}{"{}anti-\/patterns in verifiers. Cast it to a different tainted pointer "{}}}
\DoxyCodeLine{524           \textcolor{stringliteral}{"{}with sandbox\_reinterpret\_cast and then call copy\_and\_verify. "{}}}
\DoxyCodeLine{525           \textcolor{stringliteral}{"{}Alternately, you can use the UNSAFE\_unverified API to do this "{}}}
\DoxyCodeLine{526           \textcolor{stringliteral}{"{}without casting."{}});}
\DoxyCodeLine{527         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{528       \}}
\DoxyCodeLine{529       \textcolor{comment}{// Test with detail::is\_func\_ptr\_v to check for member funcs also}}
\DoxyCodeLine{530       \textcolor{keywordflow}{else} if\_constexpr\_named(subcond2, detail::is\_func\_ptr\_v<T>)}
\DoxyCodeLine{531       \{}
\DoxyCodeLine{532         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{533           subcond2,}
\DoxyCodeLine{534           \textcolor{stringliteral}{"{}copy\_and\_verify cannot be applied to function pointers as this "{}}}
\DoxyCodeLine{535           \textcolor{stringliteral}{"{}makes a deep copy. This is not possible for function pointers. "{}}}
\DoxyCodeLine{536           \textcolor{stringliteral}{"{}Consider copy\_and\_verify\_address instead."{}});}
\DoxyCodeLine{537         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{538       \}}
\DoxyCodeLine{539       \textcolor{keywordflow}{else}}
\DoxyCodeLine{540       \{}
\DoxyCodeLine{541         \textcolor{keyword}{auto} val = impl().get\_raw\_value();}
\DoxyCodeLine{542         \textcolor{keywordflow}{if} (val == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{543           \textcolor{keywordflow}{return} verifier(\textcolor{keyword}{nullptr});}
\DoxyCodeLine{544         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{545           \textcolor{comment}{// Important to assign to a local variable (i.e. make a copy)}}
\DoxyCodeLine{546           \textcolor{comment}{// Else, for tainted\_volatile, this will allow a}}
\DoxyCodeLine{547           \textcolor{comment}{// time-\/of-\/check-\/time-\/of-\/use attack}}
\DoxyCodeLine{548           \textcolor{keyword}{auto} val\_copy = std::make\_unique<T\_Deref>();}
\DoxyCodeLine{549           *val\_copy = *val;}
\DoxyCodeLine{550           \textcolor{keywordflow}{return} verifier(std::move(val\_copy));}
\DoxyCodeLine{551         \}}
\DoxyCodeLine{552       \}}
\DoxyCodeLine{553     \}}
\DoxyCodeLine{554     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{555       cond3, detail::is\_one\_level\_ptr\_v<T> \&\& std::is\_class\_v<T\_Deref>)}
\DoxyCodeLine{556     \{}
\DoxyCodeLine{557       \textcolor{keyword}{auto} val\_copy = std::make\_unique<tainted<T\_Deref, T\_Sbx>>(*impl());}
\DoxyCodeLine{558       \textcolor{keywordflow}{return} verifier(std::move(val\_copy));}
\DoxyCodeLine{559     \}}
\DoxyCodeLine{560     \textcolor{keywordflow}{else} if\_constexpr\_named(cond4, std::is\_array\_v<T>)}
\DoxyCodeLine{561     \{}
\DoxyCodeLine{562       \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{563         detail::is\_fundamental\_or\_enum\_v<std::remove\_all\_extents\_t<T>>,}
\DoxyCodeLine{564         \textcolor{stringliteral}{"{}copy\_and\_verify on arrays is only safe for fundamental or enum types. "{}}}
\DoxyCodeLine{565         \textcolor{stringliteral}{"{}For arrays of other types, apply copy\_and\_verify on each element "{}}}
\DoxyCodeLine{566         \textcolor{stringliteral}{"{}individually -\/-\/-\/ a[i].copy\_and\_verify(...)"{}});}
\DoxyCodeLine{567 }
\DoxyCodeLine{568       \textcolor{keyword}{auto} copy = impl().get\_raw\_value();}
\DoxyCodeLine{569       \textcolor{keywordflow}{return} verifier(copy);}
\DoxyCodeLine{570     \}}
\DoxyCodeLine{571     \textcolor{keywordflow}{else}}
\DoxyCodeLine{572     \{}
\DoxyCodeLine{573       \textcolor{keyword}{auto} unknownCase = !(cond1 || cond2 || cond3 || cond4);}
\DoxyCodeLine{574       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{575         unknownCase,}
\DoxyCodeLine{576         \textcolor{stringliteral}{"{}copy\_and\_verify not supported for this type as it may be unsafe"{}});}
\DoxyCodeLine{577     \}}
\DoxyCodeLine{578   \}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580 \textcolor{keyword}{private}:}
\DoxyCodeLine{581   \textcolor{keyword}{using} T\_CopyAndVerifyRangeEl =}
\DoxyCodeLine{582     detail::valid\_array\_el\_t<std::remove\_cv\_t<std::remove\_pointer\_t<T>>>;}
\DoxyCodeLine{583 }
\DoxyCodeLine{584   \textcolor{comment}{// Template needed to ensure that function isn't instantiated for unsupported}}
\DoxyCodeLine{585   \textcolor{comment}{// types like function pointers which causes compile errors...}}
\DoxyCodeLine{586   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T>}
\DoxyCodeLine{587   \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{void}* verify\_range\_helper(std::size\_t count)\textcolor{keyword}{ const}}
\DoxyCodeLine{588 \textcolor{keyword}{  }\{}
\DoxyCodeLine{589     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>);}
\DoxyCodeLine{590     \textcolor{keyword}{static\_assert}(detail::is\_fundamental\_or\_enum\_v<T\_CopyAndVerifyRangeEl>);}
\DoxyCodeLine{591 }
\DoxyCodeLine{592     detail::dynamic\_check(}
\DoxyCodeLine{593       count != 0,}
\DoxyCodeLine{594       \textcolor{stringliteral}{"{}Called copy\_and\_verify\_range/copy\_and\_verify\_string with count 0"{}});}
\DoxyCodeLine{595 }
\DoxyCodeLine{596     \textcolor{keyword}{auto} start = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(impl().get\_raw\_value());}
\DoxyCodeLine{597     \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{598       \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{599     \}}
\DoxyCodeLine{600 }
\DoxyCodeLine{601     detail::check\_range\_doesnt\_cross\_app\_sbx\_boundary<T\_Sbx>(}
\DoxyCodeLine{602       start, count * \textcolor{keyword}{sizeof}(T\_CopyAndVerifyRangeEl));}
\DoxyCodeLine{603 }
\DoxyCodeLine{604     \textcolor{keywordflow}{return} start;}
\DoxyCodeLine{605   \}}
\DoxyCodeLine{606 }
\DoxyCodeLine{607   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T>}
\DoxyCodeLine{608   \textcolor{keyword}{inline} std::unique\_ptr<T\_CopyAndVerifyRangeEl[]> copy\_and\_verify\_range\_helper(}
\DoxyCodeLine{609     std::size\_t count)\textcolor{keyword}{ const}}
\DoxyCodeLine{610 \textcolor{keyword}{  }\{}
\DoxyCodeLine{611     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* start = verify\_range\_helper(count);}
\DoxyCodeLine{612     \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{613       \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{614     \}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616     \textcolor{keyword}{auto} target = std::make\_unique<T\_CopyAndVerifyRangeEl[]>(count);}
\DoxyCodeLine{617 }
\DoxyCodeLine{618     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < count; i++) \{}
\DoxyCodeLine{619       \textcolor{keyword}{auto} p\_src\_i\_tainted = \&(impl()[i]);}
\DoxyCodeLine{620       \textcolor{keyword}{auto} p\_src\_i = p\_src\_i\_tainted.get\_raw\_value();}
\DoxyCodeLine{621       detail::convert\_type\_fundamental\_or\_array(target[i], *p\_src\_i);}
\DoxyCodeLine{622     \}}
\DoxyCodeLine{623 }
\DoxyCodeLine{624     \textcolor{keywordflow}{return} target;}
\DoxyCodeLine{625   \}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627 \textcolor{keyword}{public}:}
\DoxyCodeLine{637   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{638   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a76e49089d448ba0cfa7ef6d7c1e2d288}{copy\_and\_verify\_range}}(T\_Func verifier, std::size\_t count)\textcolor{keyword}{ const}}
\DoxyCodeLine{639 \textcolor{keyword}{  }\{}
\DoxyCodeLine{640     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{641                   \textcolor{stringliteral}{"{}Can only call copy\_and\_verify\_range on pointers"{}});}
\DoxyCodeLine{642 }
\DoxyCodeLine{643     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{644       detail::is\_fundamental\_or\_enum\_v<T\_CopyAndVerifyRangeEl>,}
\DoxyCodeLine{645       \textcolor{stringliteral}{"{}copy\_and\_verify\_range is only safe for ranges of "{}}}
\DoxyCodeLine{646       \textcolor{stringliteral}{"{}fundamental or enum types. For other types, call "{}}}
\DoxyCodeLine{647       \textcolor{stringliteral}{"{}copy\_and\_verify on each element -\/-\/-\/ a[i].copy\_and\_verify(...)"{}});}
\DoxyCodeLine{648 }
\DoxyCodeLine{649     std::unique\_ptr<T\_CopyAndVerifyRangeEl[]> target =}
\DoxyCodeLine{650       copy\_and\_verify\_range\_helper(count);}
\DoxyCodeLine{651     \textcolor{keywordflow}{return} verifier(std::move(target));}
\DoxyCodeLine{652   \}}
\DoxyCodeLine{653 }
\DoxyCodeLine{661   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{662   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_aa377cc4d0ea6768ada5032234ac89aab}{copy\_and\_verify\_string}}(T\_Func verifier)\textcolor{keyword}{ const}}
\DoxyCodeLine{663 \textcolor{keyword}{  }\{}
\DoxyCodeLine{664     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{665                   \textcolor{stringliteral}{"{}Can only call copy\_and\_verify\_string on pointers"{}});}
\DoxyCodeLine{666 }
\DoxyCodeLine{667     \textcolor{keyword}{static\_assert}(std::is\_same\_v<char, T\_CopyAndVerifyRangeEl>,}
\DoxyCodeLine{668                   \textcolor{stringliteral}{"{}copy\_and\_verify\_string only allows char*"{}});}
\DoxyCodeLine{669 }
\DoxyCodeLine{670     \textcolor{keyword}{using} T\_VerifParam = detail::func\_first\_arg\_t<T\_Func>;}
\DoxyCodeLine{671 }
\DoxyCodeLine{672     \textcolor{keyword}{auto} start = impl().get\_raw\_value();}
\DoxyCodeLine{673     if\_constexpr\_named(cond1, std::is\_same\_v<T\_VerifParam, std::unique\_ptr<\textcolor{keywordtype}{char}[]>> || std::is\_same\_v<T\_VerifParam, std::unique\_ptr<\textcolor{keyword}{const} \textcolor{keywordtype}{char}[]>>) \{}
\DoxyCodeLine{674       \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{675         \textcolor{keywordflow}{return} verifier(\textcolor{keyword}{nullptr});}
\DoxyCodeLine{676       \}}
\DoxyCodeLine{677 }
\DoxyCodeLine{678       \textcolor{comment}{// it is safe to run strlen on a tainted<string> as worst case, the string}}
\DoxyCodeLine{679       \textcolor{comment}{// does not have a null and we try to copy all the memory out of the sandbox}}
\DoxyCodeLine{680       \textcolor{comment}{// however, copy\_and\_verify\_range ensures that we never copy memory outsider}}
\DoxyCodeLine{681       \textcolor{comment}{// the range}}
\DoxyCodeLine{682       \textcolor{keyword}{auto} str\_len = std::strlen(start) + 1;}
\DoxyCodeLine{683       std::unique\_ptr<T\_CopyAndVerifyRangeEl[]> target =}
\DoxyCodeLine{684         copy\_and\_verify\_range\_helper(str\_len);}
\DoxyCodeLine{685 }
\DoxyCodeLine{686       \textcolor{comment}{// ensure the string has a trailing null}}
\DoxyCodeLine{687       target[str\_len -\/ 1] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{688 }
\DoxyCodeLine{689       \textcolor{keywordflow}{return} verifier(std::move(target));}
\DoxyCodeLine{690     \} \textcolor{keywordflow}{else} if\_constexpr\_named (cond2, std::is\_same\_v<T\_VerifParam, std::string>) \{}
\DoxyCodeLine{691       \textcolor{keywordflow}{if} (start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{692         std::string param = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{693         \textcolor{keywordflow}{return} verifier(param);}
\DoxyCodeLine{694       \}}
\DoxyCodeLine{695 }
\DoxyCodeLine{696       \textcolor{comment}{// it is safe to run strlen on a tainted<string> as worst case, the string}}
\DoxyCodeLine{697       \textcolor{comment}{// does not have a null and we try to copy all the memory out of the sandbox}}
\DoxyCodeLine{698       \textcolor{comment}{// however, copy\_and\_verify\_range ensures that we never copy memory outsider}}
\DoxyCodeLine{699       \textcolor{comment}{// the range}}
\DoxyCodeLine{700       \textcolor{keyword}{auto} str\_len = std::strlen(start) + 1;}
\DoxyCodeLine{701 }
\DoxyCodeLine{702       \textcolor{keyword}{const} \textcolor{keywordtype}{char}* checked\_start = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*) verify\_range\_helper(str\_len);}
\DoxyCodeLine{703       \textcolor{keywordflow}{if} (checked\_start == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{704         std::string param = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{705         \textcolor{keywordflow}{return} verifier(param);}
\DoxyCodeLine{706       \}}
\DoxyCodeLine{707 }
\DoxyCodeLine{708       std::string copy(checked\_start, str\_len -\/ 1);}
\DoxyCodeLine{709       \textcolor{keywordflow}{return} verifier(std::move(copy));}
\DoxyCodeLine{710     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{711       \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} unknownCase = !(cond1 || cond2);}
\DoxyCodeLine{712       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{713         unknownCase,}
\DoxyCodeLine{714         \textcolor{stringliteral}{"{}copy\_and\_verify\_string verifier parameter should either be unique\_ptr<char[]>, unique\_ptr<const char[]> or std::string"{}}}
\DoxyCodeLine{715       );}
\DoxyCodeLine{716     \}}
\DoxyCodeLine{717   \}}
\DoxyCodeLine{718 }
\DoxyCodeLine{730   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{731   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_ad34419b3444d0bf37e25ecf7d37fbe0b}{copy\_and\_verify\_address}}(T\_Func verifier)}
\DoxyCodeLine{732   \{}
\DoxyCodeLine{733     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{734                   \textcolor{stringliteral}{"{}copy\_and\_verify\_address must be used on pointers"{}});}
\DoxyCodeLine{735     \textcolor{keyword}{auto} val = \textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(impl().get\_raw\_value());}
\DoxyCodeLine{736     \textcolor{keywordflow}{return} verifier(val);}
\DoxyCodeLine{737   \}}
\DoxyCodeLine{738 }
\DoxyCodeLine{753   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Func>}
\DoxyCodeLine{754   \textcolor{keyword}{inline} \textcolor{keyword}{auto} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl_a4f739a0994af23036cce2d06b10953ee}{copy\_and\_verify\_buffer\_address}}(T\_Func verifier, std::size\_t size)}
\DoxyCodeLine{755   \{}
\DoxyCodeLine{756     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{757                   \textcolor{stringliteral}{"{}copy\_and\_verify\_address must be used on pointers"{}});}
\DoxyCodeLine{758     \textcolor{keyword}{auto} val = \textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(verify\_range\_helper(size));}
\DoxyCodeLine{759     \textcolor{keywordflow}{return} verifier(val);}
\DoxyCodeLine{760   \}}
\DoxyCodeLine{761 \};}
\DoxyCodeLine{762 }
\DoxyCodeLine{763 \textcolor{preprocessor}{\#define BinaryOpWrappedRhs(opSymbol)                                           \(\backslash\)}}
\DoxyCodeLine{764 \textcolor{preprocessor}{  template<template<typename, typename> typename T\_Wrap,                       \(\backslash\)}}
\DoxyCodeLine{765 \textcolor{preprocessor}{           typename T,                                                         \(\backslash\)}}
\DoxyCodeLine{766 \textcolor{preprocessor}{           typename T\_Sbx,                                                     \(\backslash\)}}
\DoxyCodeLine{767 \textcolor{preprocessor}{           typename T\_Lhs,                                                     \(\backslash\)}}
\DoxyCodeLine{768 \textcolor{preprocessor}{           RLBOX\_ENABLE\_IF(!detail::rlbox\_is\_wrapper\_v<T\_Lhs> \&\&               \(\backslash\)}}
\DoxyCodeLine{769 \textcolor{preprocessor}{                           !detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_Lhs>)>   \(\backslash\)}}
\DoxyCodeLine{770 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(                                     \(\backslash\)}}
\DoxyCodeLine{771 \textcolor{preprocessor}{    const T\_Lhs\& lhs, const tainted\_base\_impl<T\_Wrap, T, T\_Sbx>\& rhs)          \(\backslash\)}}
\DoxyCodeLine{772 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{773 \textcolor{preprocessor}{    }\textcolor{comment}{/* Handles the case for "{}3 + tainted"{}, where + is a binary op */}\textcolor{preprocessor}{           \(\backslash\)}}
\DoxyCodeLine{774 \textcolor{preprocessor}{    }\textcolor{comment}{/* Technically pointer arithmetic can be performed as 3 + tainted\_ptr */}\textcolor{preprocessor}{   \(\backslash\)}}
\DoxyCodeLine{775 \textcolor{preprocessor}{    }\textcolor{comment}{/* as well. However, this is unusual and to keep the code simple we do */}\textcolor{preprocessor}{  \(\backslash\)}}
\DoxyCodeLine{776 \textcolor{preprocessor}{    }\textcolor{comment}{/* not support this. */}\textcolor{preprocessor}{                                                    \(\backslash\)}}
\DoxyCodeLine{777 \textcolor{preprocessor}{    static\_assert(                                                             \(\backslash\)}}
\DoxyCodeLine{778 \textcolor{preprocessor}{      std::is\_arithmetic\_v<T\_Lhs>,                                             \(\backslash\)}}
\DoxyCodeLine{779 \textcolor{preprocessor}{      "{}Binary expressions between an non tainted type and tainted"{}}             \(\backslash\)}
\DoxyCodeLine{780       "{}type is only permitted if the first value is the tainted type. Try "{}    \(\backslash\)}
\DoxyCodeLine{781       "{}changing the order of the binary expression accordingly"{});              \(\backslash\)}
\DoxyCodeLine{782     auto ret = tainted<T\_Lhs, T\_Sbx>(lhs) opSymbol rhs.impl();                 \(\backslash\)}
\DoxyCodeLine{783     return ret;                                                                \(\backslash\)}
\DoxyCodeLine{784   \}                                                                            \(\backslash\)}
\DoxyCodeLine{785   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{786 }
\DoxyCodeLine{787 BinaryOpWrappedRhs(+);}
\DoxyCodeLine{788 BinaryOpWrappedRhs(-\/);}
\DoxyCodeLine{789 BinaryOpWrappedRhs(*);}
\DoxyCodeLine{790 BinaryOpWrappedRhs(/);}
\DoxyCodeLine{791 BinaryOpWrappedRhs(\%);}
\DoxyCodeLine{792 BinaryOpWrappedRhs(\string^);}
\DoxyCodeLine{793 BinaryOpWrappedRhs(\&);}
\DoxyCodeLine{794 BinaryOpWrappedRhs(|);}
\DoxyCodeLine{795 BinaryOpWrappedRhs(<<);}
\DoxyCodeLine{796 BinaryOpWrappedRhs(>>);}
\DoxyCodeLine{797 BinaryOpWrappedRhs(==);}
\DoxyCodeLine{798 BinaryOpWrappedRhs(!=);}
\DoxyCodeLine{799 BinaryOpWrappedRhs(<);}
\DoxyCodeLine{800 BinaryOpWrappedRhs(<=);}
\DoxyCodeLine{801 BinaryOpWrappedRhs(>);}
\DoxyCodeLine{802 BinaryOpWrappedRhs(>=);}
\DoxyCodeLine{803 \textcolor{preprocessor}{\#undef BinaryOpWrappedRhs}}
\DoxyCodeLine{804 }
\DoxyCodeLine{805 \textcolor{preprocessor}{\#define BooleanBinaryOpWrappedRhs(opSymbol)                                    \(\backslash\)}}
\DoxyCodeLine{806 \textcolor{preprocessor}{  template<template<typename, typename> typename T\_Wrap,                       \(\backslash\)}}
\DoxyCodeLine{807 \textcolor{preprocessor}{           typename T,                                                         \(\backslash\)}}
\DoxyCodeLine{808 \textcolor{preprocessor}{           typename T\_Sbx,                                                     \(\backslash\)}}
\DoxyCodeLine{809 \textcolor{preprocessor}{           typename T\_Lhs,                                                     \(\backslash\)}}
\DoxyCodeLine{810 \textcolor{preprocessor}{           RLBOX\_ENABLE\_IF(!detail::rlbox\_is\_wrapper\_v<T\_Lhs> \&\&               \(\backslash\)}}
\DoxyCodeLine{811 \textcolor{preprocessor}{                           !detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_Lhs>)>   \(\backslash\)}}
\DoxyCodeLine{812 \textcolor{preprocessor}{  inline constexpr auto operator opSymbol(                                     \(\backslash\)}}
\DoxyCodeLine{813 \textcolor{preprocessor}{    const T\_Lhs\& lhs, const tainted\_base\_impl<T\_Wrap, T, T\_Sbx>\& rhs)          \(\backslash\)}}
\DoxyCodeLine{814 \textcolor{preprocessor}{  \{                                                                            \(\backslash\)}}
\DoxyCodeLine{815 \textcolor{preprocessor}{    static\_assert(                                                             \(\backslash\)}}
\DoxyCodeLine{816 \textcolor{preprocessor}{      std::is\_arithmetic\_v<T\_Lhs>,                                             \(\backslash\)}}
\DoxyCodeLine{817 \textcolor{preprocessor}{      "{}Binary expressions between an non tainted type and tainted"{}}             \(\backslash\)}
\DoxyCodeLine{818       "{}type is only permitted if the first value is the tainted type. Try "{}    \(\backslash\)}
\DoxyCodeLine{819       "{}changing the order of the binary expression accordingly"{});              \(\backslash\)}
\DoxyCodeLine{820     auto ret = tainted<T\_Lhs, T\_Sbx>(lhs) opSymbol rhs.impl();                 \(\backslash\)}
\DoxyCodeLine{821     return ret;                                                                \(\backslash\)}
\DoxyCodeLine{822   \}                                                                            \(\backslash\)}
\DoxyCodeLine{823                                                                                \(\backslash\)}
\DoxyCodeLine{824   template<template<typename, typename> typename T\_Wrap,                       \(\backslash\)}
\DoxyCodeLine{825            typename T,                                                         \(\backslash\)}
\DoxyCodeLine{826            typename T\_Sbx,                                                     \(\backslash\)}
\DoxyCodeLine{827            typename T\_Lhs,                                                     \(\backslash\)}
\DoxyCodeLine{828            RLBOX\_ENABLE\_IF(!detail::rlbox\_is\_wrapper\_v<T\_Lhs> \&\&               \(\backslash\)}
\DoxyCodeLine{829                            !detail::rlbox\_is\_tainted\_boolean\_hint\_v<T\_Lhs>)>   \(\backslash\)}
\DoxyCodeLine{830   inline constexpr auto operator opSymbol(                                     \(\backslash\)}
\DoxyCodeLine{831     const T\_Lhs\&, const tainted\_base\_impl<T\_Wrap, T, T\_Sbx>\&\&)                 \(\backslash\)}
\DoxyCodeLine{832   \{                                                                            \(\backslash\)}
\DoxyCodeLine{833     rlbox\_detail\_static\_fail\_because(                                          \(\backslash\)}
\DoxyCodeLine{834       detail::true\_v<T\_Lhs>,                                                   \(\backslash\)}
\DoxyCodeLine{835       "{}C++ does not permit safe overloading of \&\& and || operations as this "{}  \(\backslash\)}
\DoxyCodeLine{836       "{}affects the short circuiting behaviour of these operations. RLBox "{}     \(\backslash\)}
\DoxyCodeLine{837       "{}does let you use \&\& and || with tainted in limited situations -\/ when "{}  \(\backslash\)}
\DoxyCodeLine{838       "{}all arguments starting from the second are local variables. It does "{}   \(\backslash\)}
\DoxyCodeLine{839       "{}not allow it if arguments starting from the second  are expressions.\(\backslash\)n"{} \(\backslash\)}
\DoxyCodeLine{840       "{}For example the following is not allowed\(\backslash\)n"{}                             \(\backslash\)}
\DoxyCodeLine{841       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{842       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{843       "{}auto r = a \&\& true \&\& sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}      \(\backslash\)}
\DoxyCodeLine{844       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{845       "{}However the following would be allowed\(\backslash\)n"{}                               \(\backslash\)}
\DoxyCodeLine{846       "{}tainted<bool, T\_Sbx> a = true;\(\backslash\)n"{}                                       \(\backslash\)}
\DoxyCodeLine{847       "{}auto b = true\(\backslash\)n"{}                                                        \(\backslash\)}
\DoxyCodeLine{848       "{}auto c = sandbox.invoke\_sandbox\_function(getBool);\(\backslash\)n"{}                   \(\backslash\)}
\DoxyCodeLine{849       "{}auto r = a \&\& b \&\& c;\(\backslash\)n"{}                                                \(\backslash\)}
\DoxyCodeLine{850       "{}\(\backslash\)n"{}                                                                     \(\backslash\)}
\DoxyCodeLine{851       "{}Note that these 2 programs are not identical. The first program may "{}   \(\backslash\)}
\DoxyCodeLine{852       "{}or may not call getBool, while second program always calls getBool"{});   \(\backslash\)}
\DoxyCodeLine{853     return tainted<bool, T\_Sbx>(false);                                        \(\backslash\)}
\DoxyCodeLine{854   \}                                                                            \(\backslash\)}
\DoxyCodeLine{855   RLBOX\_REQUIRE\_SEMI\_COLON}
\DoxyCodeLine{856 }
\DoxyCodeLine{857 BooleanBinaryOpWrappedRhs(\&\&);}
\DoxyCodeLine{858 BooleanBinaryOpWrappedRhs(||);}
\DoxyCodeLine{859 \textcolor{preprocessor}{\#undef BooleanBinaryOpWrappedRhs}}
\DoxyCodeLine{860 }
\DoxyCodeLine{861 \textcolor{keyword}{namespace }tainted\_detail \{}
\DoxyCodeLine{862   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{863   \textcolor{keyword}{using} tainted\_repr\_t = detail::c\_to\_std\_array\_t<T>;}
\DoxyCodeLine{864 }
\DoxyCodeLine{865   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{866   \textcolor{keyword}{using} tainted\_vol\_repr\_t =}
\DoxyCodeLine{867     detail::c\_to\_std\_array\_t<std::add\_volatile\_t<\textcolor{keyword}{typename} rlbox\_sandbox<}
\DoxyCodeLine{868       T\_Sbx>::template convert\_to\_sandbox\_equivalent\_nonclass\_t<T>>>;}
\DoxyCodeLine{869 \}}
\DoxyCodeLine{870 }
\DoxyCodeLine{875 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{876 \textcolor{keyword}{class }tainted : \textcolor{keyword}{public} tainted\_base\_impl<tainted, T, T\_Sbx>}
\DoxyCodeLine{877 \{}
\DoxyCodeLine{878   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{879   KEEP\_CAST\_FRIENDLY}
\DoxyCodeLine{880 }
\DoxyCodeLine{881   \textcolor{comment}{// Classes recieve their own specialization}}
\DoxyCodeLine{882   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{883     !std::is\_class\_v<T>,}
\DoxyCodeLine{884     \textcolor{stringliteral}{"{}Missing definition for class T. This error occurs for one "{}}}
\DoxyCodeLine{885     \textcolor{stringliteral}{"{}of 2 reasons.\(\backslash\)n"{}}}
\DoxyCodeLine{886     \textcolor{stringliteral}{"{}  1) Make sure you have include a call rlbox\_load\_structs\_from\_library "{}}}
\DoxyCodeLine{887     \textcolor{stringliteral}{"{}for this library with this class included.\(\backslash\)n"{}}}
\DoxyCodeLine{888     \textcolor{stringliteral}{"{}  2) Make sure you run (re-\/run) the struct-\/dump tool to list "{}}}
\DoxyCodeLine{889     \textcolor{stringliteral}{"{}all structs in use by your program.\(\backslash\)n"{}});}
\DoxyCodeLine{890 }
\DoxyCodeLine{891   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{892     detail::is\_basic\_type\_v<T> || std::is\_array\_v<T>,}
\DoxyCodeLine{893     \textcolor{stringliteral}{"{}Tainted types only support fundamental, enum, pointer, array and struct "{}}}
\DoxyCodeLine{894     \textcolor{stringliteral}{"{}types. Please file a bug if more support is needed."{}});}
\DoxyCodeLine{895 }
\DoxyCodeLine{896 \textcolor{keyword}{private}:}
\DoxyCodeLine{897   \textcolor{keyword}{using} T\_ClassBase = tainted\_base\_impl<tainted, T, T\_Sbx>;}
\DoxyCodeLine{898   \textcolor{keyword}{using} T\_AppType = tainted\_detail::tainted\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{899   \textcolor{keyword}{using} T\_SandboxedType = tainted\_detail::tainted\_vol\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{900   T\_AppType data;}
\DoxyCodeLine{901 }
\DoxyCodeLine{902   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_raw\_value\_ref() noexcept \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{903   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_raw\_value\_ref() const noexcept \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{904 }
\DoxyCodeLine{905   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value() const noexcept}
\DoxyCodeLine{906   \{}
\DoxyCodeLine{907     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{908   \}}
\DoxyCodeLine{909 }
\DoxyCodeLine{910   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{911     rlbox\_sandbox<T\_Sbx>\& sandbox)\textcolor{keyword}{ const}}
\DoxyCodeLine{912 \textcolor{keyword}{  }\{}
\DoxyCodeLine{913     std::remove\_cv\_t<T\_SandboxedType> ret;}
\DoxyCodeLine{914 }
\DoxyCodeLine{915     \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{916     convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{917                            adjust\_type\_direction::TO\_SANDBOX,}
\DoxyCodeLine{918                            adjust\_type\_context::SANDBOX>(}
\DoxyCodeLine{919       ret, data, \textcolor{keyword}{nullptr} \textcolor{comment}{/* example\_unsandboxed\_ptr */}, \&sandbox);}
\DoxyCodeLine{920     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{921   \};}
\DoxyCodeLine{922 }
\DoxyCodeLine{923   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value() noexcept}
\DoxyCodeLine{924   \{}
\DoxyCodeLine{925     rlbox\_detail\_forward\_to\_const(get\_raw\_value, std::remove\_cv\_t<T\_AppType>);}
\DoxyCodeLine{926   \}}
\DoxyCodeLine{927 }
\DoxyCodeLine{928   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{929     rlbox\_sandbox<T\_Sbx>\& sandbox)}
\DoxyCodeLine{930   \{}
\DoxyCodeLine{931     rlbox\_detail\_forward\_to\_const\_a(}
\DoxyCodeLine{932       get\_raw\_sandbox\_value, std::remove\_cv\_t<T\_SandboxedType>, sandbox);}
\DoxyCodeLine{933   \};}
\DoxyCodeLine{934 }
\DoxyCodeLine{935   \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{void}* find\_example\_pointer\_or\_null() const noexcept}
\DoxyCodeLine{936   \{}
\DoxyCodeLine{937     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_array\_v<T>) \{}
\DoxyCodeLine{938       \textcolor{keyword}{auto}\& data\_ref = get\_raw\_value\_ref();}
\DoxyCodeLine{939 }
\DoxyCodeLine{940       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < std::extent\_v<T>; i++) \{}
\DoxyCodeLine{941         \textcolor{keyword}{const} \textcolor{keywordtype}{void}* ret = data[i].find\_example\_pointer\_or\_null();}
\DoxyCodeLine{942         \textcolor{keywordflow}{if} (ret != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{943           \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{944         \}}
\DoxyCodeLine{945       \}}
\DoxyCodeLine{946     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_pointer\_v<T> \&\& !detail::is\_func\_ptr\_v<T>) \{}
\DoxyCodeLine{947       \textcolor{keyword}{auto} data = get\_raw\_value();}
\DoxyCodeLine{948       \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{949     \}}
\DoxyCodeLine{950     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{951   \}}
\DoxyCodeLine{952 }
\DoxyCodeLine{953   \textcolor{comment}{// Initializing with a pointer is dangerous and permitted only internally}}
\DoxyCodeLine{954   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T, RLBOX\_ENABLE\_IF(std::is\_po\textcolor{keywordtype}{int}er\_v<T2>)>}
\DoxyCodeLine{955   tainted(T2 val, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \textcolor{comment}{/* internal\_tag */})}
\DoxyCodeLine{956     : data(val)}
\DoxyCodeLine{957   \{}
\DoxyCodeLine{958     \textcolor{comment}{// Sanity check}}
\DoxyCodeLine{959     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>);}
\DoxyCodeLine{960   \}}
\DoxyCodeLine{961 }
\DoxyCodeLine{962   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{963   \textcolor{keyword}{static} \textcolor{keyword}{inline} tainted<T, T\_Sbx> internal\_factory(T\_Rhs\&\& rhs)}
\DoxyCodeLine{964   \{}
\DoxyCodeLine{965     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_pointer\_v<std::remove\_reference\_t<T\_Rhs>>) \{}
\DoxyCodeLine{966       \textcolor{keyword}{const} \textcolor{keywordtype}{void}* internal\_tag = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{967       \textcolor{keywordflow}{return} tainted(std::forward<T\_Rhs>(rhs), internal\_tag);}
\DoxyCodeLine{968     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{969       \textcolor{keywordflow}{return} tainted(std::forward<T\_Rhs>(rhs));}
\DoxyCodeLine{970     \}}
\DoxyCodeLine{971   \}}
\DoxyCodeLine{972 }
\DoxyCodeLine{973 \textcolor{keyword}{public}:}
\DoxyCodeLine{974   tainted() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{975   tainted(\textcolor{keyword}{const} tainted<T, T\_Sbx>\& p) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{976 }
\DoxyCodeLine{977   tainted(\textcolor{keyword}{const} tainted\_volatile<T, T\_Sbx>\& p)}
\DoxyCodeLine{978   \{}
\DoxyCodeLine{979     \textcolor{comment}{// Need to construct an example\_unsandboxed\_ptr for pointers or arrays of}}
\DoxyCodeLine{980     \textcolor{comment}{// pointers. Since tainted\_volatile is the type of data in sandbox memory,}}
\DoxyCodeLine{981     \textcolor{comment}{// the address of data (\&data) refers to a location in sandbox memory and}}
\DoxyCodeLine{982     \textcolor{comment}{// can thus be the example\_unsandboxed\_ptr}}
\DoxyCodeLine{983     \textcolor{keyword}{const} \textcolor{keyword}{volatile} \textcolor{keywordtype}{void}* p\_data\_ref = \&p.get\_sandbox\_value\_ref();}
\DoxyCodeLine{984     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* example\_unsandboxed\_ptr = \textcolor{keyword}{const\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(p\_data\_ref);}
\DoxyCodeLine{985     \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{986     convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{987                            adjust\_type\_direction::TO\_APPLICATION,}
\DoxyCodeLine{988                            adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{989       get\_raw\_value\_ref(),}
\DoxyCodeLine{990       p.get\_sandbox\_value\_ref(),}
\DoxyCodeLine{991       example\_unsandboxed\_ptr,}
\DoxyCodeLine{992       \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{993   \}}
\DoxyCodeLine{994 }
\DoxyCodeLine{995   \textcolor{comment}{// Initializing with a pointer is dangerous and permitted only internally}}
\DoxyCodeLine{996   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T2 = T, RLBOX\_ENABLE\_IF(std::is\_po\textcolor{keywordtype}{int}er\_v<T2>)>}
\DoxyCodeLine{997   tainted(T2 val)}
\DoxyCodeLine{998     : data(val)}
\DoxyCodeLine{999   \{}
\DoxyCodeLine{1000     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1001       std::is\_pointer\_v<T2>,}
\DoxyCodeLine{1002       \textcolor{stringliteral}{"{}Assignment of pointers is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1003       \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1004       \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1005       \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1006       \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1007       \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1008       \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1009       \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1010       \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1011       \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1012       \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1013       \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1014       \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1015       \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1016       \textcolor{stringliteral}{"{}address\(\backslash\)n "{}}}
\DoxyCodeLine{1017       \textcolor{stringliteral}{"{}4) For raw pointers, use assign\_raw\_pointer which performs required "{}}}
\DoxyCodeLine{1018       \textcolor{stringliteral}{"{}safety checks\(\backslash\)n "{}});}
\DoxyCodeLine{1019   \}}
\DoxyCodeLine{1020 }
\DoxyCodeLine{1021   tainted(}
\DoxyCodeLine{1022     \textcolor{keyword}{const} sandbox\_callback<}
\DoxyCodeLine{1023       detail::function\_ptr\_t<T> \textcolor{comment}{// Need to ensure we never generate code that}}
\DoxyCodeLine{1024                                 \textcolor{comment}{// creates a sandbox\_callback of a non function}}
\DoxyCodeLine{1025       ,}
\DoxyCodeLine{1026       T\_Sbx>\&)}
\DoxyCodeLine{1027   \{}
\DoxyCodeLine{1028     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1029       detail::true\_v<T>,}
\DoxyCodeLine{1030       \textcolor{stringliteral}{"{}RLBox does not support assigning sandbox\_callback values to tainted "{}}}
\DoxyCodeLine{1031       \textcolor{stringliteral}{"{}types (i.e. types that live in application memory).\(\backslash\)n"{}}}
\DoxyCodeLine{1032       \textcolor{stringliteral}{"{}If you still want to do this, consider changing your code to store the "{}}}
\DoxyCodeLine{1033       \textcolor{stringliteral}{"{}value in sandbox memory as follows. Convert\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1034       \textcolor{stringliteral}{"{}sandbox\_callback<T\_Func, Sbx> cb = ...;\(\backslash\)n"{}}}
\DoxyCodeLine{1035       \textcolor{stringliteral}{"{}tainted<T\_Func, Sbx> foo = cb;\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1036       \textcolor{stringliteral}{"{}to\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1037       \textcolor{stringliteral}{"{}tainted<T\_Func*, Sbx> foo\_ptr = sandbox.malloc\_in\_sandbox<T\_Func*>();\(\backslash\)n"{}}}
\DoxyCodeLine{1038       \textcolor{stringliteral}{"{}*foo\_ptr = cb;\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1039       \textcolor{stringliteral}{"{}This would keep the assignment in sandbox memory"{}});}
\DoxyCodeLine{1040   \}}
\DoxyCodeLine{1041 }
\DoxyCodeLine{1042   tainted(\textcolor{keyword}{const} std::nullptr\_t\& arg)}
\DoxyCodeLine{1043     : data(arg)}
\DoxyCodeLine{1044   \{}
\DoxyCodeLine{1045     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>);}
\DoxyCodeLine{1046   \}}
\DoxyCodeLine{1047 }
\DoxyCodeLine{1048   \textcolor{comment}{// We explicitly disable this constructor if it has one of the signatures}}
\DoxyCodeLine{1049   \textcolor{comment}{// above, so that we give the above constructors a higher priority. We only}}
\DoxyCodeLine{1050   \textcolor{comment}{// allow this for fundamental types as this is potentially unsafe for pointers}}
\DoxyCodeLine{1051   \textcolor{comment}{// and structs}}
\DoxyCodeLine{1052   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Arg,}
\DoxyCodeLine{1053            RLBOX\_ENABLE\_IF(}
\DoxyCodeLine{1054              !detail::rlbox\_is\_wrapper\_v<std::remove\_reference\_t<T\_Arg>> \&\&}
\DoxyCodeLine{1055              detail::is\_fundamental\_or\_enum\_v<T> \&\&}
\DoxyCodeLine{1056              detail::is\_fundamental\_or\_enum\_v<std::remove\_reference\_t<T\_Arg>>)>}
\DoxyCodeLine{1057   tainted(T\_Arg\&\& arg)}
\DoxyCodeLine{1058     : data(std::forward<T\_Arg>(arg))}
\DoxyCodeLine{1059   \{\}}
\DoxyCodeLine{1060 }
\DoxyCodeLine{1061   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{1062   \textcolor{keywordtype}{void} assign\_raw\_pointer(rlbox\_sandbox<T\_Sbx>\& sandbox, T\_Rhs val)}
\DoxyCodeLine{1063   \{}
\DoxyCodeLine{1064     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T\_Rhs>, \textcolor{stringliteral}{"{}Must be a pointer"{}});}
\DoxyCodeLine{1065     \textcolor{keyword}{static\_assert}(std::is\_assignable\_v<T\&, T\_Rhs>,}
\DoxyCodeLine{1066                   \textcolor{stringliteral}{"{}Should assign pointers of compatible types."{}});}
\DoxyCodeLine{1067     \textcolor{comment}{// Maybe a function pointer, so we need to cast}}
\DoxyCodeLine{1068     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* cast\_val = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(val);}
\DoxyCodeLine{1069     \textcolor{keywordtype}{bool} safe = sandbox.is\_pointer\_in\_sandbox\_memory(cast\_val);}
\DoxyCodeLine{1070     detail::dynamic\_check(}
\DoxyCodeLine{1071       safe,}
\DoxyCodeLine{1072       \textcolor{stringliteral}{"{}Tried to assign a pointer that is not in the sandbox.\(\backslash\)n "{}}}
\DoxyCodeLine{1073       \textcolor{stringliteral}{"{}This is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1074       \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1075       \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1076       \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1077       \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1078       \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1079       \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1080       \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1081       \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1082       \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1083       \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1084       \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1085       \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1086       \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1087       \textcolor{stringliteral}{"{}address\(\backslash\)n "{}});}
\DoxyCodeLine{1088     data = val;}
\DoxyCodeLine{1089   \}}
\DoxyCodeLine{1090 }
\DoxyCodeLine{1091   \textcolor{keyword}{inline} tainted\_opaque<T, T\_Sbx> to\_opaque()}
\DoxyCodeLine{1092   \{}
\DoxyCodeLine{1093     \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}tainted\_opaque<T, T\_Sbx>*\textcolor{keyword}{>}(\textcolor{keyword}{this});}
\DoxyCodeLine{1094   \}}
\DoxyCodeLine{1095 }
\DoxyCodeLine{1096   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Dummy = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1097   \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const}}
\DoxyCodeLine{1098 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1099     if\_constexpr\_named(cond1, std::is\_pointer\_v<T>)}
\DoxyCodeLine{1100     \{}
\DoxyCodeLine{1101       \textcolor{comment}{// We return this without the tainted wrapper as the checking for null}}
\DoxyCodeLine{1102       \textcolor{comment}{// doesn't really "{}induce"{} tainting in the application If the}}
\DoxyCodeLine{1103       \textcolor{comment}{// application is checking this pointer for null, then it is robust to}}
\DoxyCodeLine{1104       \textcolor{comment}{// this pointer being null or not null}}
\DoxyCodeLine{1105       \textcolor{keywordflow}{return} get\_raw\_value() != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1106     \}}
\DoxyCodeLine{1107     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1108     \{}
\DoxyCodeLine{1109       \textcolor{keyword}{auto} unknownCase = !(cond1);}
\DoxyCodeLine{1110       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1111         unknownCase,}
\DoxyCodeLine{1112         \textcolor{stringliteral}{"{}Implicit conversion to bool is only permitted for pointer types. For "{}}}
\DoxyCodeLine{1113         \textcolor{stringliteral}{"{}other types, unwrap the tainted value with the copy\_and\_verify API "{}}}
\DoxyCodeLine{1114         \textcolor{stringliteral}{"{}and then perform the required checks"{}});}
\DoxyCodeLine{1115     \}}
\DoxyCodeLine{1116   \}}
\DoxyCodeLine{1117 \};}
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{1120 \textcolor{keyword}{inline} tainted<T, T\_Sbx> from\_opaque(tainted\_opaque<T, T\_Sbx> val)}
\DoxyCodeLine{1121 \{}
\DoxyCodeLine{1122   \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}tainted<T, T\_Sbx>*\textcolor{keyword}{>}(\&val);}
\DoxyCodeLine{1123 \}}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1129 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} T\_Sbx>}
\DoxyCodeLine{1130 \textcolor{keyword}{class }\mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile}} : \textcolor{keyword}{public} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{tainted\_base\_impl}}<tainted\_volatile, T, T\_Sbx>}
\DoxyCodeLine{1131 \{}
\DoxyCodeLine{1132   KEEP\_CLASSES\_FRIENDLY}
\DoxyCodeLine{1133   KEEP\_CAST\_FRIENDLY}
\DoxyCodeLine{1134 }
\DoxyCodeLine{1135   \textcolor{comment}{// Classes recieve their own specialization}}
\DoxyCodeLine{1136   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{1137     !std::is\_class\_v<T>,}
\DoxyCodeLine{1138     \textcolor{stringliteral}{"{}Missing definition for class T. This error occurs for one "{}}}
\DoxyCodeLine{1139     \textcolor{stringliteral}{"{}of 2 reasons.\(\backslash\)n"{}}}
\DoxyCodeLine{1140     \textcolor{stringliteral}{"{}  1) Make sure you have include a call rlbox\_load\_structs\_from\_library "{}}}
\DoxyCodeLine{1141     \textcolor{stringliteral}{"{}for this library with this class included.\(\backslash\)n"{}}}
\DoxyCodeLine{1142     \textcolor{stringliteral}{"{}  2) Make sure you run (re-\/run) the struct-\/dump tool to list "{}}}
\DoxyCodeLine{1143     \textcolor{stringliteral}{"{}all structs in use by your program.\(\backslash\)n"{}});}
\DoxyCodeLine{1144 }
\DoxyCodeLine{1145   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{1146     detail::is\_basic\_type\_v<T> || std::is\_array\_v<T>,}
\DoxyCodeLine{1147     \textcolor{stringliteral}{"{}Tainted types only support fundamental, enum, pointer, array and struct "{}}}
\DoxyCodeLine{1148     \textcolor{stringliteral}{"{}types. Please file a bug if more support is needed."{}});}
\DoxyCodeLine{1149 }
\DoxyCodeLine{1150 \textcolor{keyword}{private}:}
\DoxyCodeLine{1151   \textcolor{keyword}{using} \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{T\_ClassBase}} = \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{tainted\_base\_impl<tainted\_volatile, T, T\_Sbx>}};}
\DoxyCodeLine{1152   \textcolor{keyword}{using} T\_AppType = tainted\_detail::tainted\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{1153   \textcolor{keyword}{using} T\_SandboxedType = tainted\_detail::tainted\_vol\_repr\_t<T, T\_Sbx>;}
\DoxyCodeLine{1154   T\_SandboxedType data;}
\DoxyCodeLine{1155 }
\DoxyCodeLine{1156   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_sandbox\_value\_ref() \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{1157   \textcolor{keyword}{inline} \textcolor{keyword}{auto}\& get\_sandbox\_value\_ref() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} data; \}}
\DoxyCodeLine{1158 }
\DoxyCodeLine{1159   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value()\textcolor{keyword}{ const}}
\DoxyCodeLine{1160 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1161     std::remove\_cv\_t<T\_AppType> ret;}
\DoxyCodeLine{1162     \textcolor{comment}{// Need to construct an example\_unsandboxed\_ptr for pointers or arrays of}}
\DoxyCodeLine{1163     \textcolor{comment}{// pointers. Since tainted\_volatile is the type of data in sandbox memory,}}
\DoxyCodeLine{1164     \textcolor{comment}{// the address of data (\&data) refers to a location in sandbox memory and}}
\DoxyCodeLine{1165     \textcolor{comment}{// can thus be the example\_unsandboxed\_ptr}}
\DoxyCodeLine{1166     \textcolor{keyword}{const} \textcolor{keyword}{volatile} \textcolor{keywordtype}{void}* data\_ref = \&data;}
\DoxyCodeLine{1167     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* example\_unsandboxed\_ptr = \textcolor{keyword}{const\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(data\_ref);}
\DoxyCodeLine{1168     \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{1169     convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{1170                            adjust\_type\_direction::TO\_APPLICATION,}
\DoxyCodeLine{1171                            adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{1172       ret, data, example\_unsandboxed\_ptr, \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{1173     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{1174   \}}
\DoxyCodeLine{1175 }
\DoxyCodeLine{1176   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value()}
\DoxyCodeLine{1177     \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1178   \{}
\DoxyCodeLine{1179     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{1180   \};}
\DoxyCodeLine{1181 }
\DoxyCodeLine{1182   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{1183     \mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1184   \{}
\DoxyCodeLine{1185     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{1186     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{1187   \};}
\DoxyCodeLine{1188 }
\DoxyCodeLine{1189   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_AppType> get\_raw\_value()}
\DoxyCodeLine{1190   \{}
\DoxyCodeLine{1191     rlbox\_detail\_forward\_to\_const(get\_raw\_value, std::remove\_cv\_t<T\_AppType>);}
\DoxyCodeLine{1192   \}}
\DoxyCodeLine{1193 }
\DoxyCodeLine{1194   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1195   \{}
\DoxyCodeLine{1196     rlbox\_detail\_forward\_to\_const(get\_raw\_sandbox\_value,}
\DoxyCodeLine{1197                                   std::remove\_cv\_t<T\_SandboxedType>);}
\DoxyCodeLine{1198   \};}
\DoxyCodeLine{1199 }
\DoxyCodeLine{1200   \textcolor{keyword}{inline} std::remove\_cv\_t<T\_SandboxedType> get\_raw\_sandbox\_value(}
\DoxyCodeLine{1201     \mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1202   \{}
\DoxyCodeLine{1203     RLBOX\_UNUSED(sandbox);}
\DoxyCodeLine{1204     rlbox\_detail\_forward\_to\_const(get\_raw\_sandbox\_value,}
\DoxyCodeLine{1205                                   std::remove\_cv\_t<T\_SandboxedType>);}
\DoxyCodeLine{1206   \};}
\DoxyCodeLine{1207 }
\DoxyCodeLine{1208   \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1209   \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile}}(\textcolor{keyword}{const} \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile<T, T\_Sbx>}}\& p) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1210 }
\DoxyCodeLine{1211 \textcolor{keyword}{public}:}
\DoxyCodeLine{1212   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<const T*, T\_Sbx>}} operator\&() \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1213   \{}
\DoxyCodeLine{1214     \textcolor{keyword}{auto} ref =}
\DoxyCodeLine{1215       detail::remove\_volatile\_from\_ptr\_cast(\&this-\/>get\_sandbox\_value\_ref());}
\DoxyCodeLine{1216     \textcolor{keyword}{auto} ref\_cast = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }T*\textcolor{keyword}{>}(ref);}
\DoxyCodeLine{1217     \textcolor{keyword}{auto} ret = \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<const T*, T\_Sbx>::internal\_factory}}(ref\_cast);}
\DoxyCodeLine{1218     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{1219   \}}
\DoxyCodeLine{1220 }
\DoxyCodeLine{1221   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<T*, T\_Sbx>}} operator\&() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{1222   \{}
\DoxyCodeLine{1223     \textcolor{keyword}{using} T\_Ret = \mbox{\hyperlink{classrlbox_1_1tainted}{tainted<T*, T\_Sbx>}};}
\DoxyCodeLine{1224     rlbox\_detail\_forward\_to\_const(\textcolor{keyword}{operator}\&, T\_Ret);}
\DoxyCodeLine{1225   \}}
\DoxyCodeLine{1226 }
\DoxyCodeLine{1227   \textcolor{comment}{// Needed as the definition of unary \& above shadows the base's binary \&}}
\DoxyCodeLine{1228   rlbox\_detail\_forward\_binop\_to\_base(\&, \mbox{\hyperlink{classrlbox_1_1tainted__base__impl}{T\_ClassBase}});}
\DoxyCodeLine{1229 }
\DoxyCodeLine{1230   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_RhsRef>}
\DoxyCodeLine{1231   \textcolor{keyword}{inline} \mbox{\hyperlink{classrlbox_1_1tainted__volatile}{tainted\_volatile<T, T\_Sbx>}}\& operator=(T\_RhsRef\&\& val)}
\DoxyCodeLine{1232   \{}
\DoxyCodeLine{1233     \textcolor{keyword}{using} T\_Rhs = std::remove\_reference\_t<T\_RhsRef>;}
\DoxyCodeLine{1234     \textcolor{keyword}{using} T\_Rhs\_El = std::remove\_all\_extents\_t<T\_Rhs>;}
\DoxyCodeLine{1235 }
\DoxyCodeLine{1236     \textcolor{comment}{// Need to construct an example\_unsandboxed\_ptr for pointers or arrays of}}
\DoxyCodeLine{1237     \textcolor{comment}{// pointers. Since tainted\_volatile is the type of data in sandbox memory,}}
\DoxyCodeLine{1238     \textcolor{comment}{// the address of data (\&data) refers to a location in sandbox memory and}}
\DoxyCodeLine{1239     \textcolor{comment}{// can thus be the example\_unsandboxed\_ptr}}
\DoxyCodeLine{1240     \textcolor{keyword}{const} \textcolor{keyword}{volatile} \textcolor{keywordtype}{void}* data\_ref = \&get\_sandbox\_value\_ref();}
\DoxyCodeLine{1241     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* example\_unsandboxed\_ptr = \textcolor{keyword}{const\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(data\_ref);}
\DoxyCodeLine{1242     \textcolor{comment}{// Some branches don't use this}}
\DoxyCodeLine{1243     RLBOX\_UNUSED(example\_unsandboxed\_ptr);}
\DoxyCodeLine{1244 }
\DoxyCodeLine{1245     if\_constexpr\_named(}
\DoxyCodeLine{1246       cond1, std::is\_same\_v<std::remove\_const\_t<T\_Rhs>, std::nullptr\_t>)}
\DoxyCodeLine{1247     \{}
\DoxyCodeLine{1248       \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T>,}
\DoxyCodeLine{1249                     \textcolor{stringliteral}{"{}Null pointer can only be assigned to pointers"{}});}
\DoxyCodeLine{1250       \textcolor{comment}{// assign using an integer instead of nullptr, as the pointer field may be}}
\DoxyCodeLine{1251       \textcolor{comment}{// represented as integer}}
\DoxyCodeLine{1252       data = 0;}
\DoxyCodeLine{1253     \}}
\DoxyCodeLine{1254     \textcolor{keywordflow}{else} if\_constexpr\_named(cond2, detail::rlbox\_is\_tainted\_v<T\_Rhs>)}
\DoxyCodeLine{1255     \{}
\DoxyCodeLine{1256       \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{1257       convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{1258                              adjust\_type\_direction::TO\_SANDBOX,}
\DoxyCodeLine{1259                              adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{1260         get\_sandbox\_value\_ref(),}
\DoxyCodeLine{1261         val.get\_raw\_value\_ref(),}
\DoxyCodeLine{1262         example\_unsandboxed\_ptr,}
\DoxyCodeLine{1263         \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{1264     \}}
\DoxyCodeLine{1265     \textcolor{keywordflow}{else} if\_constexpr\_named(cond3, detail::rlbox\_is\_tainted\_volatile\_v<T\_Rhs>)}
\DoxyCodeLine{1266     \{}
\DoxyCodeLine{1267       \textcolor{keyword}{using namespace }detail;}
\DoxyCodeLine{1268       convert\_type\_non\_class<T\_Sbx,}
\DoxyCodeLine{1269                              adjust\_type\_direction::NO\_CHANGE,}
\DoxyCodeLine{1270                              adjust\_type\_context::EXAMPLE>(}
\DoxyCodeLine{1271         get\_sandbox\_value\_ref(),}
\DoxyCodeLine{1272         val.get\_sandbox\_value\_ref(),}
\DoxyCodeLine{1273         example\_unsandboxed\_ptr,}
\DoxyCodeLine{1274         \textcolor{keyword}{nullptr} \textcolor{comment}{/* sandbox\_ptr */});}
\DoxyCodeLine{1275     \}}
\DoxyCodeLine{1276     \textcolor{keywordflow}{else} if\_constexpr\_named(cond4, detail::rlbox\_is\_sandbox\_callback\_v<T\_Rhs>)}
\DoxyCodeLine{1277     \{}
\DoxyCodeLine{1278       \textcolor{keyword}{using} T\_RhsFunc = detail::rlbox\_remove\_wrapper\_t<T\_Rhs>;}
\DoxyCodeLine{1279 }
\DoxyCodeLine{1280       \textcolor{comment}{// need to perform some typechecking to ensure we are assigning compatible}}
\DoxyCodeLine{1281       \textcolor{comment}{// function pointer types only}}
\DoxyCodeLine{1282       if\_constexpr\_named(subcond1, !std::is\_assignable\_v<T\&, T\_RhsFunc>)}
\DoxyCodeLine{1283       \{}
\DoxyCodeLine{1284         rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1285           subcond1,}
\DoxyCodeLine{1286           \textcolor{stringliteral}{"{}Trying to assign function pointer to field of incompatible types"{}});}
\DoxyCodeLine{1287       \}}
\DoxyCodeLine{1288       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1289       \{}
\DoxyCodeLine{1290         \textcolor{comment}{// Need to reinterpret\_cast as the representation of the signature of a}}
\DoxyCodeLine{1291         \textcolor{comment}{// callback uses the machine model of the sandbox, while the field uses}}
\DoxyCodeLine{1292         \textcolor{comment}{// that of the application. But we have already checked above that this}}
\DoxyCodeLine{1293         \textcolor{comment}{// is safe.}}
\DoxyCodeLine{1294         \textcolor{keyword}{auto} func = val.get\_raw\_sandbox\_value();}
\DoxyCodeLine{1295         \textcolor{keyword}{using} T\_Cast = std::remove\_volatile\_t<T\_SandboxedType>;}
\DoxyCodeLine{1296         get\_sandbox\_value\_ref() = (T\_Cast)func;}
\DoxyCodeLine{1297       \}}
\DoxyCodeLine{1298     \}}
\DoxyCodeLine{1299     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{1300       cond5,}
\DoxyCodeLine{1301       detail::is\_fundamental\_or\_enum\_v<T> ||}
\DoxyCodeLine{1302         (std::is\_array\_v<T> \&\& !std::is\_pointer\_v<T\_Rhs\_El>))}
\DoxyCodeLine{1303     \{}
\DoxyCodeLine{1304       detail::convert\_type\_fundamental\_or\_array(get\_sandbox\_value\_ref(), val);}
\DoxyCodeLine{1305     \}}
\DoxyCodeLine{1306     \textcolor{keywordflow}{else} if\_constexpr\_named(}
\DoxyCodeLine{1307       cond6, std::is\_pointer\_v<T\_Rhs> || std::is\_pointer\_v<T\_Rhs\_El>)}
\DoxyCodeLine{1308     \{}
\DoxyCodeLine{1309       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1310         cond6,}
\DoxyCodeLine{1311         \textcolor{stringliteral}{"{}Assignment of pointers is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1312         \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1313         \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1314         \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1315         \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1316         \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1317         \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1318         \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1319         \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1320         \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1321         \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1322         \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1323         \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1324         \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1325         \textcolor{stringliteral}{"{}address\(\backslash\)n "{}}}
\DoxyCodeLine{1326         \textcolor{stringliteral}{"{}4) For raw pointers, use assign\_raw\_pointer which performs required "{}}}
\DoxyCodeLine{1327         \textcolor{stringliteral}{"{}safety checks\(\backslash\)n "{}});}
\DoxyCodeLine{1328     \}}
\DoxyCodeLine{1329     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1330     \{}
\DoxyCodeLine{1331       \textcolor{keyword}{auto} unknownCase =}
\DoxyCodeLine{1332         !(cond1 || cond2 || cond3 || cond4 || cond5 \textcolor{comment}{/* || cond6 */});}
\DoxyCodeLine{1333       rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1334         unknownCase, \textcolor{stringliteral}{"{}Assignment of the given type of value is not supported"{}});}
\DoxyCodeLine{1335     \}}
\DoxyCodeLine{1336 }
\DoxyCodeLine{1337     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1338   \}}
\DoxyCodeLine{1339 }
\DoxyCodeLine{1340   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Rhs>}
\DoxyCodeLine{1341   \textcolor{keywordtype}{void} assign\_raw\_pointer(\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox}{rlbox\_sandbox<T\_Sbx>}}\& sandbox, T\_Rhs val)}
\DoxyCodeLine{1342   \{}
\DoxyCodeLine{1343     \textcolor{keyword}{static\_assert}(std::is\_pointer\_v<T\_Rhs>, \textcolor{stringliteral}{"{}Must be a pointer"{}});}
\DoxyCodeLine{1344     \textcolor{keyword}{static\_assert}(std::is\_assignable\_v<T\&, T\_Rhs>,}
\DoxyCodeLine{1345                   \textcolor{stringliteral}{"{}Should assign pointers of compatible types."{}});}
\DoxyCodeLine{1346     \textcolor{comment}{// Maybe a function pointer, so we need to cast}}
\DoxyCodeLine{1347     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* cast\_val = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(val);}
\DoxyCodeLine{1348     \textcolor{keywordtype}{bool} safe = sandbox.\mbox{\hyperlink{classrlbox_1_1rlbox__sandbox_a55e48f0300c16d36ea7ed5a7e4750f64}{is\_pointer\_in\_sandbox\_memory}}(cast\_val);}
\DoxyCodeLine{1349     detail::dynamic\_check(}
\DoxyCodeLine{1350       safe,}
\DoxyCodeLine{1351       \textcolor{stringliteral}{"{}Tried to assign a pointer that is not in the sandbox.\(\backslash\)n "{}}}
\DoxyCodeLine{1352       \textcolor{stringliteral}{"{}This is not safe as it could\(\backslash\)n "{}}}
\DoxyCodeLine{1353       \textcolor{stringliteral}{"{}1) Leak pointers from the appliction to the sandbox which may break "{}}}
\DoxyCodeLine{1354       \textcolor{stringliteral}{"{}ASLR\(\backslash\)n "{}}}
\DoxyCodeLine{1355       \textcolor{stringliteral}{"{}2) Pass inaccessible pointers to the sandbox leading to crash\(\backslash\)n "{}}}
\DoxyCodeLine{1356       \textcolor{stringliteral}{"{}3) Break sandboxes that require pointers to be swizzled first\(\backslash\)n "{}}}
\DoxyCodeLine{1357       \textcolor{stringliteral}{"{}\(\backslash\)n "{}}}
\DoxyCodeLine{1358       \textcolor{stringliteral}{"{}Instead, if you want to pass in a pointer, do one of the following\(\backslash\)n "{}}}
\DoxyCodeLine{1359       \textcolor{stringliteral}{"{}1) Allocate with malloc\_in\_sandbox, and pass in a tainted pointer\(\backslash\)n "{}}}
\DoxyCodeLine{1360       \textcolor{stringliteral}{"{}2) For pointers that point to functions in the application, register "{}}}
\DoxyCodeLine{1361       \textcolor{stringliteral}{"{}with sandbox.register\_callback(\(\backslash\)"{}foo\(\backslash\)"{}), and pass in the registered "{}}}
\DoxyCodeLine{1362       \textcolor{stringliteral}{"{}value\(\backslash\)n "{}}}
\DoxyCodeLine{1363       \textcolor{stringliteral}{"{}3) For pointers that point to functions in the sandbox, get the "{}}}
\DoxyCodeLine{1364       \textcolor{stringliteral}{"{}address with get\_sandbox\_function\_address(sandbox, foo), and pass in "{}}}
\DoxyCodeLine{1365       \textcolor{stringliteral}{"{}the "{}}}
\DoxyCodeLine{1366       \textcolor{stringliteral}{"{}address\(\backslash\)n "{}});}
\DoxyCodeLine{1367     get\_sandbox\_value\_ref() =}
\DoxyCodeLine{1368       sandbox.template get\_sandboxed\_pointer<T\_Rhs>(cast\_val);}
\DoxyCodeLine{1369   \}}
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_Dummy = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1372   \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const}}
\DoxyCodeLine{1373 \textcolor{keyword}{  }\{}
\DoxyCodeLine{1374     rlbox\_detail\_static\_fail\_because(}
\DoxyCodeLine{1375       detail::true\_v<T\_Dummy>,}
\DoxyCodeLine{1376       \textcolor{stringliteral}{"{}Cannot apply implicit conversion to bool on values that are located in "{}}}
\DoxyCodeLine{1377       \textcolor{stringliteral}{"{}sandbox memory. This error occurs if you compare a dereferenced value "{}}}
\DoxyCodeLine{1378       \textcolor{stringliteral}{"{}such as the code shown below\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1379       \textcolor{stringliteral}{"{}tainted<int**> a = ...;\(\backslash\)n"{}}}
\DoxyCodeLine{1380       \textcolor{stringliteral}{"{}assert(*a);\(\backslash\)n\(\backslash\)n"{}}}
\DoxyCodeLine{1381       \textcolor{stringliteral}{"{}Instead you can write this code as \(\backslash\)n"{}}}
\DoxyCodeLine{1382       \textcolor{stringliteral}{"{}tainted<int*> temp = *a;\(\backslash\)n"{}}}
\DoxyCodeLine{1383       \textcolor{stringliteral}{"{}assert(temp);\(\backslash\)n"{}});}
\DoxyCodeLine{1384     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1385   \}}
\DoxyCodeLine{1386 \};}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388 \}}

\end{DoxyCode}
