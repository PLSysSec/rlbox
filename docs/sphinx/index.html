
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>1 Overview &#8212; RLBox Sandboxing API  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="auto-toc simple">
<li><p><a class="reference internal" href="#overview" id="id8"><span class="sectnum">1</span> Overview</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#example-library-sandboxing" id="id9"><span class="sectnum">1.1</span> Example library sandboxing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#core-api" id="id10"><span class="sectnum">2</span> Core API</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#creating-and-destroying-sandboxes" id="id11"><span class="sectnum">2.1</span> Creating (and destroying) sandboxes</a></p></li>
<li><p><a class="reference internal" href="#calling-sandboxed-library-functions" id="id12"><span class="sectnum">2.2</span> Calling sandboxed library functions</a></p></li>
<li><p><a class="reference internal" href="#exposing-functions-to-sandboxed-code" id="id13"><span class="sectnum">2.3</span> Exposing functions to sandboxed code</a></p></li>
<li><p><a class="reference internal" href="#tainted-values" id="id14"><span class="sectnum">2.4</span> Tainted values</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#unwrapping-tainted-values" id="id15"><span class="sectnum">2.4.1</span> Unwrapping tainted values</a></p></li>
<li><p><a class="reference internal" href="#operating-on-tainted-values" id="id16"><span class="sectnum">2.4.2</span> Operating on tainted values</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#application-sandbox-shared-memory" id="id17"><span class="sectnum">2.5</span> Application-sandbox shared memory</a></p></li>
<li><p><a class="reference internal" href="#migrating-code-by-temporarily-removing-tainting" id="id18"><span class="sectnum">2.6</span> Migrating code by temporarily removing tainting</a></p></li>
<li><p><a class="reference internal" href="#standard-library" id="id19"><span class="sectnum">2.7</span> Standard library</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#handling-more-complex-abis" id="id20"><span class="sectnum">3</span> Handling more complex ABIs</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#passing-structs-to-from-a-sandbox" id="id21"><span class="sectnum">3.1</span> Passing structs to/from a sandbox</a></p></li>
<li><p><a class="reference internal" href="#invoking-varargs-functions" id="id22"><span class="sectnum">3.2</span> Invoking varargs functions</a></p></li>
<li><p><a class="reference internal" href="#invoking-c-functions-in-a-sandbox" id="id23"><span class="sectnum">3.3</span> Invoking C++ functions in a sandbox</a></p></li>
<li><p><a class="reference internal" href="#passing-application-pointers-into-the-sandbox-with-app-pointer" id="id24"><span class="sectnum">3.4</span> Passing application pointers into the sandbox with <cite>app_pointer</cite></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#additional-material" id="id25"><span class="sectnum">4</span> Additional material</a></p></li>
<li><p><a class="reference internal" href="#references" id="id26"><span class="sectnum">5</span> References</a></p></li>
<li><p><a class="reference internal" href="#indices-and-tables" id="id27"><span class="sectnum">6</span> Indices and tables</a></p></li>
</ul>
</div>
<div class="toctree-wrapper compound">
</div>
<section id="overview">
<h1><a class="toc-backref" href="#id8"><span class="sectnum">1</span> Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<p>This is a short tutorial on the RLBox API. If you are looking for a reference
of all APIs, see <a class="reference internal" href="#doxygen" id="id1"><span>[Doxygen]</span></a>.  If you are looking for motivation, see
<a class="reference internal" href="#rlboxlogin" id="id2"><span>[RLBoxLogin]</span></a>, <a class="reference internal" href="#rlboxfirefox" id="id3"><span>[RLBoxFirefox]</span></a>, and <a class="reference internal" href="#rlboxpaper" id="id4"><span>[RLBoxPaper]</span></a>.</p>
<p>RLBox is a toolkit for sandboxing third-party libraries. The toolkit consists
of (1) a Wasm-based sandbox and (2) an API for retrofitting existing
application code to interface with a sandboxed library.  The Wasm-based sandbox
is documented in its <a class="reference external" href="https://github.com/PLSysSec/rlbox_wasm2c_sandbox">corresponding repository</a>. While, the RLBox API can
be used with different sandbox implementations, this documentation focuses on
the API and the interface you will use when sandboxing code, independent of the
underlying sandboxing mechanism.</p>
<p><strong>Why do we need a sandboxing API?</strong>
Sandboxing libraries without the RLBox API is both tedious and error-prone.
This is especially the case when retrofitting an existing codebase like Firefox
where libraries are trusted and thus the application-library boundary is
blurry.  To sandbox a library – and thus to move to a world where the library
is no longer trusted – we need to modify this application-library boundary.
For example, we need to add security checks in Firefox to ensure that any value
from the sandboxed library is properly validated before it is used.  Otherwise,
the library (when compromised) may be able to abuse Firefox code to hijack its
control flow (see <a class="reference internal" href="#rlboxpaper" id="id5"><span>[RLBoxPaper]</span></a> for details). The RLBox API
is explicitly designed to make retrofitting of existing application code
simpler and less error-prone.</p>
<p><strong>Sandboxing architecture overview</strong> As shown in <a class="reference internal" href="#arch-fig"><span class="std std-numref">Fig. 1</span></a>, RLBox ensures that a
sandboxed library is <em>memory isolated</em> from the rest of the application – the
library cannot directly access memory outside its designated region – and that
all <em>boundary crossings are explicit</em>. This ensures that the library cannot,
for example, corrupt Firefox’s address space. It also ensures that Firefox
cannot inadvertently expose sensitive data to the library (e.g., pointers that
would leak its ASLR).</p>
<figure class="align-center" id="id7">
<span id="arch-fig"></span><img alt="RLBox architecture" src="_images/arch.png" />
<figcaption>
<p><span class="caption-number">Fig. 1 </span><span class="caption-text">Sandboxed libraries are isolated from the application and all communication
between the sandboxed library and application code is mediated. This ensures
that the application code is robust and does not use untrusted,
<a class="reference internal" href="#tainted"><span class="std std-ref">tainted values</span></a> without checking them.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Memory isolation is enforced by the underlying sandboxing mechanism (from the
start, when you create the sandbox with <a class="reference internal" href="#create-sandbox"><span class="std std-ref">create_sandbox()</span></a>). Explicit
boundary crossings are enforced by RLBox (either at compile- or and run-time).
For example, with RLBox you can’t call library functions directly; instead, you
must use the <a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a> method. Similarly, the library cannot
call arbitrary Firefox functions; instead, it can only call functions that you
expose with the <a class="reference internal" href="#register-callback"><span class="std std-ref">register_callback()</span></a> method. (To
simplify the sandboxing task, though, RLBox does expose a standard library as
described in <a class="reference internal" href="#stdlib"><span class="std std-ref">2.7   Standard library</span></a>.)</p>
<p>When calling a library function, RLBox copies simple values into the sandbox
memory before calling the function. For larger data types, such as structs and
arrays, you can’t simply pass a pointer to the object. This would leak ASLR
and, more importantly, would not work: sandboxed code cannot access application
memory.  So, you must explicitly allocate memory in the sandbox via
<a class="reference internal" href="#malloc-in-sandbox"><span class="std std-ref">malloc_in_sandbox()</span></a> and copy application data to
this region of memory (e.g., via <code class="docutils literal notranslate"><span class="pre">strncpy</span></code>).</p>
<p>RLBox similarly copies simple return values and callback arguments. Larger data
structures, however, must (again) be passed by <em>sandbox-reference</em>, i.e., via a
reference/pointer to sandbox memory.</p>
<p>To ensure that application code doesn’t use values that originate in the
sandbox – and may thus be under the control of an attacker – unsafely, RLBox
considers all such values as untrusted and <a class="reference internal" href="#tainted"><span class="std std-ref">taints</span></a> them.
Tainted values are essentially opaque values (though RLBox does provide some
<a class="reference internal" href="#tainted-ops"><span class="std std-ref">basic operators on tainted values</span></a>). To use a tainted
value, you must unwrap it by copying the value into application memory – and
thus out of the reach of the attacker – and <em>verifying</em> it. Indeed, RLBox
forces application code to perform the copy and verification in sync using
<a class="reference internal" href="#verification"><span class="std std-ref">verifiction functions</span></a>.</p>
<section id="example-library-sandboxing">
<h2><a class="toc-backref" href="#id9"><span class="sectnum">1.1</span> Example library sandboxing</a><a class="headerlink" href="#example-library-sandboxing" title="Permalink to this headline">¶</a></h2>
<p>To get a feel for what it’s like to use RLBox, we’re going to sandbox a tiny
library <code class="docutils literal notranslate"><span class="pre">mylib</span></code> that has four functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">mylib</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>

<span class="n">void</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Hello world from mylib</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">unsigned</span> <span class="n">add</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">a</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">echo</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;&gt; mylib: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">call_cb</span><span class="p">(</span><span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)</span> <span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">str</span><span class="p">))</span> <span class="p">{</span>
   <span class="n">cb</span><span class="p">(</span><span class="s2">&quot;hi again!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">get_error_code</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not the most interesting library, security-wise, but it is complicated
enough to demonstrate various RLBox features.</p>
<p>To get started, in our main application file let’s first import the RLBox
library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">main</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span>

<span class="c1">#define RLBOX_SINGLE_THREADED_INVOCATIONS</span>
<span class="c1">#define RLBOX_USE_STATIC_CALLS() rlbox_noop_sandbox_lookup_symbol</span>

<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &quot;mylib.h&quot;</span>
<span class="c1">#include &quot;rlbox.hpp&quot;</span>
<span class="c1">#include &quot;rlbox_noop_sandbox.hpp&quot;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">rlbox</span><span class="p">;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>In our main function, let’s now create a new sandbox (for this example we’re
going to use the NULL sandbox) and call the <code class="docutils literal notranslate"><span class="pre">hello</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="n">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

   <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">sandbox</span>
   <span class="n">rlbox</span><span class="p">::</span><span class="n">rlbox_sandbox</span><span class="o">&lt;</span><span class="n">rlbox_noop_sandbox</span><span class="o">&gt;</span> <span class="n">sandbox</span><span class="p">;</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">create_sandbox</span><span class="p">();</span>

   <span class="o">//</span> <span class="n">call</span> <span class="n">the</span> <span class="n">library</span> <span class="n">hello</span> <span class="n">function</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Note that we do not call <code class="docutils literal notranslate"><span class="pre">hello()</span></code> directly. Instead, we use the
<a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a> method. We can similarly call the
<code class="docutils literal notranslate"><span class="pre">add</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="o">//</span> <span class="n">call</span> <span class="n">the</span> <span class="n">add</span> <span class="n">function</span> <span class="ow">and</span> <span class="n">check</span> <span class="n">the</span> <span class="n">result</span><span class="p">:</span>
   <span class="n">auto</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">copy_and_verify</span><span class="p">([](</span><span class="n">unsigned</span> <span class="n">ret</span><span class="p">){</span>
         <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Adding... 3+4 = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
         <span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">7</span><span class="p">;</span>
   <span class="p">});</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;OK? = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ok</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>This invocation is a bit more interesting. First, we call <code class="docutils literal notranslate"><span class="pre">add</span></code> with
arguments. Second, RLBox ensures that the <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> return value that
<code class="docutils literal notranslate"><span class="pre">add</span></code> returns is <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> and thus cannot be used without
verification. Here, we call the copy_and_verify
function which copies the value into application memory and runs our verifier
function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[](</span><span class="n">unsigned</span> <span class="n">ret</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Adding... 3+4 = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This lambda simply prints the tainted value and returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if it is
<code class="docutils literal notranslate"><span class="pre">7</span></code>. A compromised library could return any value and if we use this value
to, say, index an array this could potentially introduce an out-of-bounds
memory access.</p>
<p>Let’s now call the <code class="docutils literal notranslate"><span class="pre">echo</span></code> function which takes a slightly more interesting
argument: a string. Here, we can’t simply pass a string literal as an argument:
the sandbox cannot access application memory where this would be allocated.
Instead, we must allocate a buffer in sandbox memory and copy the string we
want to pass to <code class="docutils literal notranslate"><span class="pre">echo</span></code> into this region:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">helloStr</span> <span class="o">=</span> <span class="s2">&quot;hi hi!&quot;</span><span class="p">;</span>
   <span class="n">size_t</span> <span class="n">helloSize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">helloStr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="o">//</span> <span class="n">allocate</span> <span class="n">memory</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">sandbox</span><span class="p">:</span>
   <span class="n">auto</span> <span class="n">taintedStr</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">malloc_in_sandbox</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">helloSize</span><span class="p">);</span>
   <span class="o">//</span> <span class="n">copy</span> <span class="n">helloStr</span> <span class="n">into</span> <span class="n">the</span> <span class="n">sandbox</span><span class="p">:</span>
   <span class="n">std</span><span class="p">::</span><span class="n">strncpy</span><span class="p">(</span><span class="n">taintedStr</span><span class="o">.</span><span class="n">unverified_safe_pointer_because</span><span class="p">(</span><span class="n">helloSize</span><span class="p">,</span> <span class="s2">&quot;writing to region&quot;</span><span class="p">),</span> <span class="n">helloStr</span><span class="p">,</span> <span class="n">helloSize</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">taintedStr</span></code> is actually a <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> string: it
lives in the sandbox memory and could be written to by the (compromised)
library code concurrently. As such, it’s unsafe for us to use this pointer
without verification. Above, we use the “unverified_safe_pointer_because”
verifier which basically removes the taint without
any verification. This is safe because we copy the <code class="docutils literal notranslate"><span class="pre">helloStr</span></code> to sandbox
memory: at worst, the sandboxed library can overwrite the memory region pointed
to by <code class="docutils literal notranslate"><span class="pre">taintedStr</span></code> and crash when it tries to print it.</p>
<p>Note that the string “writing to region” does not have any special meaning in
the code. Rather the RLBox API asks you to provide a free-form string that acts
as documentation. Essentially you are providing a string saying “it is safe to
remove the tainting from this type because …”. Such documentation may be
useful to other developers who read your code. As discussed, in the above
example, a write to the region cannot cause a memory safety error in the
application”.</p>
<p>Now, we can just call the function and free the allocated string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">echo</span><span class="p">,</span> <span class="n">taintedStr</span><span class="p">);</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">free_in_sandbox</span><span class="p">(</span><span class="n">taintedStr</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Finally, let’s call the <code class="docutils literal notranslate"><span class="pre">call_cb</span></code> function. To do this, let’s first define a
callback for the function to call. We define this function above the <code class="docutils literal notranslate"><span class="pre">main</span></code>
function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>...
void hello_cb(rlbox_sandbox&lt;rlbox_noop_sandbox&gt;&amp; _,
            tainted&lt;const char*, rlbox_noop_sandbox&gt; str) {
   auto checked_string =
      str.copy_and_verify_string([](std::unique_ptr&lt;char[]&gt; val) {
         return std::strlen(val.get()) &lt; 1024 ? std::move(val) : nullptr;
      });
   printf(&quot;hello_cb: %s\n&quot;, checked_string.get());
}
...
</pre></div>
</div>
<p>This callback is called with a string. We thus call the <a class="reference internal" href="#copy-and-verify-string"><span class="std std-ref">string
verification function</span></a> with a simple verifier:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>...
   [](std::unique_ptr&lt;char[]&gt; val) {
        return std::strlen(val.get()) &lt; 1024 ? std::move(val) : nullptr;
    }
...
</pre></div>
</div>
<p>This verifier moves the string if it’s length is less than 1KB and otherwise
returns the <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. In the callback we simply print this (potentially
null) string.</p>
<p>Let’s now continue in <code class="docutils literal notranslate"><span class="pre">main</span></code>, register the callback – otherwise RLBox will
disallow the library-application call – and pass the callback to the
<code class="docutils literal notranslate"><span class="pre">call_cb</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>...
   // register callback and call it
   auto cb = sandbox.register_callback(hello_cb);
   sandbox.invoke_sandbox_function(call_cb, cb);

   // `cb` is unregistered automatically once it goes out of scope
   // Once unregistered, the callback cannot be invoked any further
   // We can also manually unregister it if we want to unregister it sooner
   cb.unregister();
...
</pre></div>
</div>
<p>Finally, let’s destroy the sandbox and exit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
   <span class="o">//</span> <span class="n">destroy</span> <span class="n">sandbox</span>
   <span class="n">sandbox</span><span class="o">.</span><span class="n">destroy_sandbox</span><span class="p">();</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="core-api">
<h1><a class="toc-backref" href="#id10"><span class="sectnum">2</span> Core API</a><a class="headerlink" href="#core-api" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe a large part of the RLBox API you are likely to
encounter when porting libraries. The API has some more advanced features and
types that are necessary but not as commonly used (see <a class="reference internal" href="#doxygen" id="id6"><span>[Doxygen]</span></a>).  In most
cases the RLBox type system will give you an informative error if and how to
use these features.</p>
<section id="creating-and-destroying-sandboxes">
<h2><a class="toc-backref" href="#id11"><span class="sectnum">2.1</span> Creating (and destroying) sandboxes</a><a class="headerlink" href="#creating-and-destroying-sandboxes" title="Permalink to this headline">¶</a></h2>
<p>RLBox encapsulates sandboxes with <a class="reference internal" href="#rlbox-sandbox"><span class="std std-ref">rlbox_sandbox</span></a> class.
For now, RLBox supports two sandboxes: a Wasm-based sandboxed and the <em>null</em>
sandbox. The null sandbox doesn’t actually enforce any isolation, but is very
useful for migrating an existing codebase to use the RLBox API.  In fact, in
most cases you want to port the existing code to use RLBox when interfacing
with a particular library and only then switch over to the Wasm-based sandbox.</p>
<span class="target" id="rlbox-sandbox"></span><dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I0EN5rlbox13rlbox_sandboxE">
<span id="_CPPv3I0EN5rlbox13rlbox_sandboxE"></span><span id="_CPPv2I0EN5rlbox13rlbox_sandboxE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1rlbox__sandbox"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rlbox_sandbox</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">protected</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><a class="headerlink" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Encapsulation for sandboxes. </p>
<p><dl class="field-list simple">
<dt class="field-odd">tparam T_Sbx</dt>
<dd class="field-odd"><p>Type of sandbox. For the null sandbox this is <code class="docutils literal notranslate"><a class="reference internal" href="#classrlbox_1_1rlbox__noop__sandbox"><span class="std std-ref"><span class="pre">rlbox_noop_sandbox</span></span></a></code> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4N5rlbox18rlbox_noop_sandboxE">
<span id="_CPPv3N5rlbox18rlbox_noop_sandboxE"></span><span id="_CPPv2N5rlbox18rlbox_noop_sandboxE"></span><span id="rlbox::rlbox_noop_sandbox"></span><span class="target" id="classrlbox_1_1rlbox__noop__sandbox"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rlbox_noop_sandbox</span></span></span><a class="headerlink" href="#_CPPv4N5rlbox18rlbox_noop_sandboxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Class that implements the null sandbox. This sandbox doesn’t actually provide any isolation and only serves as a stepping stone towards migrating an application to use the RLBox API. </p>
</dd></dl>

<span class="target" id="create-sandbox"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4IDpEN5rlbox13rlbox_sandbox14create_sandboxEbDp6T_Args">
<span id="_CPPv3IDpEN5rlbox13rlbox_sandbox14create_sandboxEDp6T_Args"></span><span id="_CPPv2IDpEN5rlbox13rlbox_sandbox14create_sandboxEDp6T_Args"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="sig-name descname"><span class="n"><span class="pre">T_Args</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1rlbox__sandbox_1a8d10eac11ee829943be5aa3bb8f43137"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">create_sandbox</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN5rlbox13rlbox_sandbox14create_sandboxEbDp6T_Args" title="rlbox::rlbox_sandbox::create_sandbox::T_Args"><span class="n"><span class="pre">T_Args</span></span></a><span class="p"><span class="pre">...</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN5rlbox13rlbox_sandbox14create_sandboxEbDp6T_Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new sandbox. </p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters</dt>
<dd class="field-odd"><p><strong>T_args</strong> – Arguments passed to the underlying sandbox implementation. For the null sandbox, no arguments are necessary. </p>
</dd>
</dl>
</dd></dl>

<p>Creating sandboxes is mostly straightforward.  For the null sandbox, however,
you need to add a <code class="docutils literal notranslate"><span class="pre">#define</span></code> at the top of your entry file, before you include
the RLBox headers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define RLBOX_USE_STATIC_CALLS() rlbox_noop_sandbox_lookup_symbol</span>
<span class="o">...</span>
<span class="n">rlbox</span><span class="p">::</span><span class="n">rlbox_sandbox</span><span class="o">&lt;</span><span class="n">rlbox_noop_sandbox</span><span class="o">&gt;</span> <span class="n">sandbox</span><span class="p">;</span>
<span class="n">sandbox</span><span class="o">.</span><span class="n">create_sandbox</span><span class="p">();</span>
</pre></div>
</div>
<span class="target" id="destroy-sandbox"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5rlbox13rlbox_sandbox15destroy_sandboxEv">
<span id="_CPPv3N5rlbox13rlbox_sandbox15destroy_sandboxEv"></span><span id="_CPPv2N5rlbox13rlbox_sandbox15destroy_sandboxEv"></span><span id="rlbox::rlbox_sandbox::destroy_sandbox"></span><span class="target" id="classrlbox_1_1rlbox__sandbox_1ac2be161ed2183fa8bc319232a8d74da6"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">destroy_sandbox</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5rlbox13rlbox_sandbox15destroy_sandboxEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy sandbox and reclaim any memory. </p>
</dd></dl>

<p>It’s important to destroy a sandbox after you are done with it. This ensures
that the memory footprint of sandboxing remains low. Once you destroy a sandbox
though, it is an error to use the sandbox object.</p>
</section>
<section id="calling-sandboxed-library-functions">
<h2><a class="toc-backref" href="#id12"><span class="sectnum">2.2</span> Calling sandboxed library functions</a><a class="headerlink" href="#calling-sandboxed-library-functions" title="Permalink to this headline">¶</a></h2>
<p>RLBox disallows code from calling sandboxed library functions directly.
Instead, application code must use the <a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a>
method.</p>
<span class="target" id="invoke-sandbox-function"></span><dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.invoke_sandbox_function">
<span class="target" id="rlbox__sandbox_8hpp_1a6b8bbccd72eceee956de6e616dd7a798"></span><span class="sig-name descname"><span class="n"><span class="pre">invoke_sandbox_function</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">func_name</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invoke_sandbox_function" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Call sandbox function. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func_name</strong> – The sandboxed library function to call. </p></li>
<li><p><strong>...</strong> – Arguments to function should be simple or tainted values. </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tainted value or void. </p>
</dd>
</dl>
</dd></dl>

<p>Though this function is defined via macros, RLBox uses some template and macro
magic to make this look like a <a class="reference internal" href="#rlbox-sandbox"><span class="std std-ref">sandbox</span></a> method. So, in
general, you can call sandboxed library functions as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">call</span> <span class="n">foo</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="exposing-functions-to-sandboxed-code">
<h2><a class="toc-backref" href="#id13"><span class="sectnum">2.3</span> Exposing functions to sandboxed code</a><a class="headerlink" href="#exposing-functions-to-sandboxed-code" title="Permalink to this headline">¶</a></h2>
<p>Application code can expose <a class="reference internal" href="#callback"><span class="std std-ref">callback functions</span></a> to sandbox via
<a class="reference internal" href="#register-callback"><span class="std std-ref">register_callback()</span></a>.  These functions can be called
by the sandboxed code until they (1) are no longer in scope or (2) are
explicitly unregistered via the <cite>unregister()</cite> function.</p>
<p id="register-callback">The type signatures of <a class="reference internal" href="#register-callback"><span class="std std-ref">register_callback()</span></a>
function is a bit daunting. In short, the function takes a <a class="reference internal" href="#callback"><span class="std std-ref">callback
function</span></a> and returns a function pointer that can be passed to the
sandbox (e.g., via <a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a>).</p>
<p id="callback">A <em>callback function</em> is a function that has a special type:</p>
<ul class="simple">
<li><p>The first argument of the function must be a reference a <a class="reference internal" href="#rlbox-sandbox"><span class="std std-ref">sandbox</span></a> object.</p></li>
<li><p>The remaining arguments must be <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a>.</p></li>
<li><p>The return value must be <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> or <code class="docutils literal notranslate"><span class="pre">void</span></code>. This ensures
that the application cannot accidentally leak data to the sandbox.</p></li>
</ul>
<p>Forcing arguments to be <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> forces the application to
handled values coming from the sandbox with care. Dually, the return type
ensures that the application cannot accidentally leak data to the sandbox.</p>
</section>
<section id="tainted-values">
<h2><a class="toc-backref" href="#id14"><span class="sectnum">2.4</span> Tainted values</a><a class="headerlink" href="#tainted-values" title="Permalink to this headline">¶</a></h2>
<p>Values that originate in the sandbox are <em>tainted</em>. We use a special tainted
type <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> to encapsulate such values and prevent the
application from using tainted values unsafely.</p>
<span class="target" id="tainted"></span><dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I00EN5rlbox7taintedE">
<span id="_CPPv3I00EN5rlbox7taintedE"></span><span id="_CPPv2I00EN5rlbox7taintedE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1tainted"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tainted</span></span></span><a class="headerlink" href="#_CPPv4I00EN5rlbox7taintedE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>RLBox has several kinds of tainted values, beyond <a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a>.
Thse, however, are slightly less pervasive in the surface API.</p>
<span class="target" id="tainted-volatile"></span><dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I00EN5rlbox16tainted_volatileE">
<span id="_CPPv3I00EN5rlbox16tainted_volatileE"></span><span id="_CPPv2I00EN5rlbox16tainted_volatileE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1tainted__volatile"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tainted_volatile</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">tainted_base_impl</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00EN5rlbox16tainted_volatileE" title="rlbox::tainted_volatile"><span class="n"><span class="pre">tainted_volatile</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox16tainted_volatileE" title="rlbox::tainted_volatile::T"><span class="n"><span class="pre">T</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox16tainted_volatileE" title="rlbox::tainted_volatile::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><a class="headerlink" href="#_CPPv4I00EN5rlbox16tainted_volatileE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tainted volatile values are like tainted values but still point to sandbox memory. Dereferencing a tainted pointer produces a <a class="reference internal" href="#classrlbox_1_1tainted__volatile"><span class="std std-ref">tainted_volatile</span></a>. </p>
</dd></dl>

<span class="target" id="tainted-boolean-hint"></span><dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4N5rlbox20tainted_boolean_hintE">
<span id="_CPPv3N5rlbox20tainted_boolean_hintE"></span><span id="_CPPv2N5rlbox20tainted_boolean_hintE"></span><span id="rlbox::tainted_boolean_hint"></span><span class="target" id="classrlbox_1_1tainted__boolean__hint"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tainted_boolean_hint</span></span></span><a class="headerlink" href="#_CPPv4N5rlbox20tainted_boolean_hintE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tainted boolean value that serves as a “hint” and not a definite answer. Comparisons with a <a class="reference internal" href="#classrlbox_1_1tainted__volatile"><span class="std std-ref">tainted_volatile</span></a> return such hints. They are not <code class="docutils literal notranslate"><span class="pre">tainted&lt;bool&gt;</span></code> values because a compromised sandbox can modify <a class="reference internal" href="#classrlbox_1_1tainted__volatile"><span class="std std-ref">tainted_volatile</span></a> data at any time. </p>
</dd></dl>

<section id="unwrapping-tainted-values">
<span id="verification"></span><h3><a class="toc-backref" href="#id15"><span class="sectnum">2.4.1</span> Unwrapping tainted values</a><a class="headerlink" href="#unwrapping-tainted-values" title="Permalink to this headline">¶</a></h3>
<p>To use tainted values, the application can copy
the value to application memory, verify the value, and unwrap it. RLBox
provides several functions to do this.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>doxygenfunction: Unable to resolve function “copy_and_verify” with arguments None in doxygen xml output for project “RLBox” from directory: /home/d/hack/rlbox_sandboxing_api/docs/doxygen/xml.
Potential matches:
</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="n">void</span><span class="o">&gt;</span> <span class="nb">bool</span> <span class="n">copy_and_verify</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">const</span>
<span class="o">-</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="n">void</span><span class="o">&gt;</span> <span class="nb">int</span> <span class="n">copy_and_verify</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">const</span>
<span class="o">-</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">T_Func</span><span class="o">&gt;</span> <span class="n">auto</span> <span class="n">copy_and_verify</span><span class="p">(</span><span class="n">T_Func</span> <span class="n">verifier</span><span class="p">)</span> <span class="n">const</span>
</pre></div>
</div>
</div>
<p>For a given tainted type, the verifier should have the following signature:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 21%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tainted type kind</p></th>
<th class="head"><p>Example type</p></th>
<th class="head"><p>Example verifier</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Simple type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(int)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Pointer to simple type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(unique_ptr&lt;int&gt;)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Pointer to class type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Foo*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(unique_ptr&lt;Foo&gt;)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Pointer to array</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int[4]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(std::array&lt;int,</span> <span class="pre">4&gt;)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Class type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Foo</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T_Ret(*)(tainted&lt;Foo&gt;)</span></code></p></td>
</tr>
</tbody>
</table>
<p>In general, the return type of the verifier <code class="docutils literal notranslate"><span class="pre">T_Ret</span></code> is not constrained and can
be anything the caller chooses.</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0ENK5rlbox17tainted_base_impl21copy_and_verify_rangeEDa6T_FuncNSt6size_tE">
<span id="_CPPv3I0ENK5rlbox17tainted_base_impl21copy_and_verify_rangeE6T_FuncNSt6size_tE"></span><span id="_CPPv2I0ENK5rlbox17tainted_base_impl21copy_and_verify_rangeE6T_FuncNSt6size_tE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Func</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1tainted__base__impl_1a76e49089d448ba0cfa7ef6d7c1e2d288"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">tainted_base_impl</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">copy_and_verify_range</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0ENK5rlbox17tainted_base_impl21copy_and_verify_rangeEDa6T_FuncNSt6size_tE" title="rlbox::tainted_base_impl::copy_and_verify_range::T_Func"><span class="n"><span class="pre">T_Func</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">verifier</span></span>, <span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">count</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4I0ENK5rlbox17tainted_base_impl21copy_and_verify_rangeEDa6T_FuncNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a range of tainted values from sandbox and verify them. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verifer</strong> – Function used to verify the copied value. </p></li>
<li><p><strong>count</strong> – Number of elements to copy. </p></li>
</ul>
</dd>
<dt class="field-even">Template Parameters</dt>
<dd class="field-even"><p><strong>T_Func</strong> – the type of the verifier. If the tainted type is <code class="docutils literal notranslate"><span class="pre">int*</span></code> then <code class="docutils literal notranslate"><span class="pre">T_Func</span> <span class="pre">=</span> <span class="pre">T_Ret(*)(unique_ptr&lt;int[]&gt;)</span></code>. </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Whatever the verifier function returns. </p>
</dd>
</dl>
</dd></dl>

<span class="target" id="copy-and-verify-string"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0ENK5rlbox17tainted_base_impl22copy_and_verify_stringEDa6T_Func">
<span id="_CPPv3I0ENK5rlbox17tainted_base_impl22copy_and_verify_stringE6T_Func"></span><span id="_CPPv2I0ENK5rlbox17tainted_base_impl22copy_and_verify_stringE6T_Func"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Func</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1tainted__base__impl_1aa377cc4d0ea6768ada5032234ac89aab"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">tainted_base_impl</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">copy_and_verify_string</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0ENK5rlbox17tainted_base_impl22copy_and_verify_stringEDa6T_Func" title="rlbox::tainted_base_impl::copy_and_verify_string::T_Func"><span class="n"><span class="pre">T_Func</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">verifier</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4I0ENK5rlbox17tainted_base_impl22copy_and_verify_stringEDa6T_Func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a tainted string from sandbox and verify it. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verifer</strong> – Function used to verify the copied value. </p>
</dd>
<dt class="field-even">Template Parameters</dt>
<dd class="field-even"><p><strong>T_Func</strong> – the type of the verifier either <code class="docutils literal notranslate"><span class="pre">T_Ret(*)(unique_ptr&lt;char[]&gt;)</span></code> or <code class="docutils literal notranslate"><span class="pre">T_Ret(*)(std::string)</span></code> </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Whatever the verifier function returns. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN5rlbox17tainted_base_impl23copy_and_verify_addressEDa6T_Func">
<span id="_CPPv3I0EN5rlbox17tainted_base_impl23copy_and_verify_addressE6T_Func"></span><span id="_CPPv2I0EN5rlbox17tainted_base_impl23copy_and_verify_addressE6T_Func"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Func</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1tainted__base__impl_1ad34419b3444d0bf37e25ecf7d37fbe0b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">tainted_base_impl</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">copy_and_verify_address</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN5rlbox17tainted_base_impl23copy_and_verify_addressEDa6T_Func" title="rlbox::tainted_base_impl::copy_and_verify_address::T_Func"><span class="n"><span class="pre">T_Func</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">verifier</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5rlbox17tainted_base_impl23copy_and_verify_addressEDa6T_Func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a tainted pointer from sandbox and verify the address. </p>
<p>This function is useful if you need to verify physical bits representing the address of a pointer. Other APIs such as copy_and_verify performs a deep copy and changes the address bits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verifier</strong> – Function used to verify the copied value. </p>
</dd>
<dt class="field-even">Template Parameters</dt>
<dd class="field-even"><p><strong>T_Func</strong> – the type of the verifier <code class="docutils literal notranslate"><span class="pre">T_Ret(*)(uintptr_t)</span></code> </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Whatever the verifier function returns. </p>
</dd>
</dl>
</dd></dl>

<p>In some cases it’s useful to unwrap tainted values without verification.
Sometimes this is safe to do and RLBox provides a method for doing so
called <code class="docutils literal notranslate"><span class="pre">unverified_safe_because</span></code></p>
<p>Since pointers are special (sandbox code may modify the data the pointer
points to), we have a similar function for pointers called
unverified_safe_pointer_because. This API requires specifying the number of
elements being pointed to for safety.</p>
<p>We however provide additional functions that are especially useful during
migration:</p>
<span class="target" id="unsafe-unverified"></span><dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4II00E000EN5rlbox17tainted_base_implE">
<span id="_CPPv3II00E000EN5rlbox17tainted_base_implE"></span><span id="_CPPv2II00E000EN5rlbox17tainted_base_implE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Wrap</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1tainted__base__impl"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tainted_base_impl</span></span></span><a class="headerlink" href="#_CPPv4II00E000EN5rlbox17tainted_base_implE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5rlbox17tainted_base_impl17UNSAFE_unverifiedEv">
<span id="_CPPv3N5rlbox17tainted_base_impl17UNSAFE_unverifiedEv"></span><span id="_CPPv2N5rlbox17tainted_base_impl17UNSAFE_unverifiedEv"></span><span id="rlbox::tainted_base_impl::UNSAFE_unverified"></span><span class="target" id="classrlbox_1_1tainted__base__impl_1a01acab6b4bd8137afa03cf4b2678844f"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UNSAFE_unverified</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5rlbox17tainted_base_impl17UNSAFE_unverifiedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unwrap a tainted value without verification. This is an unsafe operation and should be used with care. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N5rlbox17tainted_base_impl16UNSAFE_sandboxedER13rlbox_sandboxI5T_SbxE">
<span id="_CPPv3N5rlbox17tainted_base_impl16UNSAFE_sandboxedER13rlbox_sandboxI5T_SbxE"></span><span id="_CPPv2N5rlbox17tainted_base_impl16UNSAFE_sandboxedER13rlbox_sandboxI5T_SbxE"></span><span id="rlbox::tainted_base_impl::UNSAFE_sandboxed__rlbox_sandbox:T_Sbx:R"></span><span class="target" id="classrlbox_1_1tainted__base__impl_1ae2c69129cbb9344e7d2623129f031214"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UNSAFE_sandboxed</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4II00E000EN5rlbox17tainted_base_implE" title="rlbox::tainted_base_impl::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sandbox</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5rlbox17tainted_base_impl16UNSAFE_sandboxedER13rlbox_sandboxI5T_SbxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Like UNSAFE_unverified, but get the underlying sandbox representation. </p>
<p>
For the Wasm-based sandbox, this function additionally validates the unwrapped value against the machine model of the sandbox (LP32). </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sandbox</strong> – Reference to sandbox.</p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<p>These functions are also available for <a class="reference internal" href="#callback"><span class="std std-ref">callback</span></a></p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>Unchecked unwrapped tainted values can be abused by a compromised
or malicious library to potentially compromise the application.</p>
</div>
</section>
<section id="operating-on-tainted-values">
<span id="tainted-ops"></span><h3><a class="toc-backref" href="#id16"><span class="sectnum">2.4.2</span> Operating on tainted values</a><a class="headerlink" href="#operating-on-tainted-values" title="Permalink to this headline">¶</a></h3>
<p>Unwrapping tainted values requires care – getting a verifier wrong could lead
to a security vulnerability. It’s also not cheap: we need to copy data to the
application memory to ensure that the sandboxed code cannot modify the data
we’re tyring to verify. Lucikly, it’s not always necessary to copy and verify:
sometimes we can compute on tainted values directly. To this end, RLBox defines
different kinds of operators on tainted values, which produce tainted values.
This allows you to perform some computations on tainted values, pass the values
back into the sandbox, and only later unwrap a tainted value when you need to.
operators like <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> on tainted values.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Class of operator</p></th>
<th class="head"><p>Supported operators</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Arithmetic operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>,
<code class="docutils literal notranslate"><span class="pre">++</span></code>, <code class="docutils literal notranslate"><span class="pre">--</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Relational operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Logical operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">!</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (limited), <code class="docutils literal notranslate"><span class="pre">||</span></code> (limited)</p></td>
</tr>
<tr class="row-odd"><td><p>Bitwise operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">~</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Compound operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>,
<code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Pointer operators</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code></p></td>
</tr>
</tbody>
</table>
<p>When applying a binary operator like <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> to a tainted value and an untainted
values the result is always tainted.</p>
<p>RLBox also defines several comparison operators on tainted values that sometime
unwrap the result:</p>
<ul class="simple">
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code> on tainted pointers is allowed if the rhs is
<code class="docutils literal notranslate"><span class="pre">nullptr_t</span></code> and return unwrapped <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p></li>
<li><p>Operator <code class="docutils literal notranslate"><span class="pre">!</span></code> on tainted pointers retruns an unwrapped <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p></li>
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code> on non-pointer tainted values return a
<code class="docutils literal notranslate"><span class="pre">tainted&lt;bool&gt;</span></code></p></li>
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code> on <a class="reference internal" href="#tainted-volatile"><span class="std std-ref">tainted_volatile</span></a>
values returns a <a class="reference internal" href="#tainted-boolean-hint"><span class="std std-ref">tainted_boolean_hint</span></a></p></li>
<li><p>Operators <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> on booleans are only permitted when arguments are
variables (not expressions). This is because C++ does not permit safe
overloading of &amp;&amp; and || operations with expression arguments as this affects
the short circuiting behaviour of these operations.</p></li>
</ul>
</section>
</section>
<section id="application-sandbox-shared-memory">
<h2><a class="toc-backref" href="#id17"><span class="sectnum">2.5</span> Application-sandbox shared memory</a><a class="headerlink" href="#application-sandbox-shared-memory" title="Permalink to this headline">¶</a></h2>
<p>Since sandboxed code cannot access application memory, to share objects across
the boundary you need to explicitly allocate memory that both the application
and sandbox can access. To this end, <a class="reference internal" href="#malloc-in-sandbox"><span class="std std-ref">malloc_in_sandbox()</span></a> allocates memory within the sandbox region and returns a
<a class="reference internal" href="#tainted"><span class="std std-ref">tainted</span></a> pointer that can be used by both the application and
sandbox (e.g., by passing the pointer as an argument to a function).</p>
<span class="target" id="malloc-in-sandbox"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE7taintedIP1T5T_SbxEv">
<span id="_CPPv3I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxEv"></span><span id="_CPPv2I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxEv"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1rlbox__sandbox_1a8ba59f981ba2b463e8e3629b22cc3bee"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox7taintedE" title="rlbox::tainted"><span class="n"><span class="pre">tainted</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE7taintedIP1T5T_SbxEv" title="rlbox::rlbox_sandbox::malloc_in_sandbox::T"><span class="n"><span class="pre">T</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">T_Sbx</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">malloc_in_sandbox</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE7taintedIP1T5T_SbxEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new pointer that is accessible to both the application and sandbox. The pointer is allocated in sandbox memory. </p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters</dt>
<dd class="field-odd"><p><strong>T</strong> – The type of the pointer you want to create. If T=int, this would return a pointer to an int.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tainted&lt;T*, T_Sbx&gt; Tainted pointer accessible to the application and sandbox. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE7taintedIP1T5T_SbxE8uint32_t">
<span id="_CPPv3I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE8uint32_t"></span><span id="_CPPv2I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE8uint32_t"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1rlbox__sandbox_1a5f7bca36b7a7a8df4c9212ceff78d5be"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox7taintedE" title="rlbox::tainted"><span class="n"><span class="pre">tainted</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE7taintedIP1T5T_SbxE8uint32_t" title="rlbox::rlbox_sandbox::malloc_in_sandbox::T"><span class="n"><span class="pre">T</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">T_Sbx</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">malloc_in_sandbox</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5rlbox13rlbox_sandbox17malloc_in_sandboxE7taintedIP1T5T_SbxE8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an array that is accessible to both the application and sandbox. The pointer is allocated in sandbox memory. </p>
<dl class="field-list simple">
<dt class="field-odd">Template Parameters</dt>
<dd class="field-odd"><p><strong>T</strong> – The type of the array elements you want to create. If T=int, this would return a pointer to an array of ints.</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>count</strong> – The number of array elements to allocate.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>tainted&lt;T*, T_Sbx&gt; Tainted pointer accessible to the application and sandbox. </p>
</dd>
</dl>
</dd></dl>

<p>Manually allocated memory is freed explicitly:</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN5rlbox13rlbox_sandbox15free_in_sandboxEv7taintedIP1T5T_SbxE">
<span id="_CPPv3I0EN5rlbox13rlbox_sandbox15free_in_sandboxE7taintedIP1T5T_SbxE"></span><span id="_CPPv2I0EN5rlbox13rlbox_sandbox15free_in_sandboxE7taintedIP1T5T_SbxE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="classrlbox_1_1rlbox__sandbox_1a775b1828f996dc8f14f24a296096e0e3"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">free_in_sandbox</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN5rlbox7taintedE" title="rlbox::tainted"><span class="n"><span class="pre">tainted</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandbox15free_in_sandboxEv7taintedIP1T5T_SbxE" title="rlbox::rlbox_sandbox::free_in_sandbox::T"><span class="n"><span class="pre">T</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">T_Sbx</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5rlbox13rlbox_sandbox15free_in_sandboxEv7taintedIP1T5T_SbxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free the memory referenced by the tainted pointer. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ptr</strong> – Pointer to sandbox memory to free. </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="migrating-code-by-temporarily-removing-tainting">
<h2><a class="toc-backref" href="#id18"><span class="sectnum">2.6</span> Migrating code by temporarily removing tainting</a><a class="headerlink" href="#migrating-code-by-temporarily-removing-tainting" title="Permalink to this headline">¶</a></h2>
<p>RLBox is designed to simplify working with existing applications/code bases.
Rather than migrating an application to use RLBox’s APIs in a single shot, RLBox
allows “incremental migration” to simplify this step. In particular, migrating
existing code to use RLBox APIs i.e. using <cite>tainted</cite> types and replacing
function calls to libraries with <a class="reference internal" href="#invoke-sandbox-function"><span class="std std-ref">invoke_sandbox_function()</span></a> method, can be performed one line at a time. After
each such migration, you can continue to build, run/test the program with full
functionality to make sure the migration step is correct.</p>
<p>For example consider migrating some existing code that uses <code class="docutils literal notranslate"><span class="pre">mylib</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">app</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>

<span class="n">void</span> <span class="n">print_error_message</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">char</span><span class="o">*</span> <span class="n">msgs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;Success&quot;</span><span class="p">,</span> <span class="s2">&quot;Fail&quot;</span> <span class="p">};</span>
   <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">get_error_code</span><span class="p">();</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Result: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msgs</span><span class="p">[</span><span class="n">result</span><span class="p">]);</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Rather than migrating the full function to use RLBox, you can migrate just the
call to <code class="docutils literal notranslate"><span class="pre">get_error_code</span></code> by leveraging the <a class="reference internal" href="#unsafe-unverified"><span class="std std-ref">UNSAFE_unverified</span></a> APIs to removing the tainting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">app</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>

<span class="n">void</span> <span class="n">print_error_message</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">char</span><span class="o">*</span> <span class="n">msgs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;Success&quot;</span><span class="p">,</span> <span class="s2">&quot;Fail&quot;</span> <span class="p">};</span>

   <span class="o">//</span> <span class="n">Migrate</span> <span class="n">this</span> <span class="n">line</span> <span class="n">to</span> <span class="n">use</span> <span class="n">the</span> <span class="n">RLBox</span> <span class="n">API</span>
   <span class="n">tainted</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">rlbox_noop_sandbox</span><span class="o">&gt;</span> <span class="n">tainted_result</span> <span class="o">=</span> <span class="n">get_error_code</span><span class="p">();</span>
   <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">tainted_result</span><span class="o">.</span><span class="n">UNSAFE_unverified</span><span class="p">();</span>

   <span class="o">//</span> <span class="n">Not</span> <span class="n">migrated</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Result: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msgs</span><span class="p">[</span><span class="n">result</span><span class="p">]);</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Observe that by renaming variables, we can easily leave the other lines of code unmodified.
After building and testing this step, we can now migrate the line that prints the message:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">app</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>

<span class="n">void</span> <span class="n">print_error_message</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">char</span><span class="o">*</span> <span class="n">msgs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;Success&quot;</span><span class="p">,</span> <span class="s2">&quot;Fail&quot;</span> <span class="p">};</span>

   <span class="o">//</span> <span class="n">Migrate</span> <span class="n">this</span> <span class="n">line</span> <span class="n">to</span> <span class="n">use</span> <span class="n">the</span> <span class="n">RLBox</span> <span class="n">API</span>
   <span class="n">auto</span> <span class="n">tainted_result</span> <span class="o">=</span> <span class="n">get_error_code</span><span class="p">();</span>

   <span class="o">//</span> <span class="n">Not</span> <span class="n">migrated</span>
   <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Result: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msgs</span><span class="p">[</span><span class="n">tainted_result</span><span class="o">.</span><span class="n">UNSAFE_unverified</span><span class="p">()]);</span>

   <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">tainted_result</span><span class="o">.</span><span class="n">UNSAFE_unverified</span><span class="p">();</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, we can proceed with replacing all uses of result in the <code class="docutils literal notranslate"><span class="pre">...</span></code> portion of code as well.</p>
<p>As the “UNSAFE” portion of the <code class="docutils literal notranslate"><span class="pre">UNSAFE_unverified</span></code> API indicates, migration is
<strong>NOT</strong> complete until we replace the uses of <code class="docutils literal notranslate"><span class="pre">UNSAFE_unverified</span></code> with
<code class="docutils literal notranslate"><span class="pre">copy_and_verify</span></code> or <code class="docutils literal notranslate"><span class="pre">unverified_safe_because</span></code> as discussed in
<a class="reference internal" href="#verification"><span class="std std-ref">2.4.1   Unwrapping tainted values</span></a>. Here, the since <code class="docutils literal notranslate"><span class="pre">tainted_result</span></code> is being used to access
an array of size 2, we can verify it as shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Result: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msgs</span><span class="p">[</span><span class="n">tainted_result</span><span class="o">.</span><span class="n">copy_and_verify</span><span class="p">([](</span><span class="nb">int</span> <span class="n">val</span><span class="p">){</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="n">abort</span><span class="p">();</span> <span class="p">}</span>
   <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}));</span>
</pre></div>
</div>
<p>The exact opposite of the <code class="docutils literal notranslate"><span class="pre">UNSAFE_unverified</span></code> function i.e. converting
regularly “untainted” data to <code class="docutils literal notranslate"><span class="pre">tainted</span></code> is also available:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 12%" />
<col style="width: 32%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tainted type kind</p></th>
<th class="head"><p>Example type</p></th>
<th class="head"><p>Converted type</p></th>
<th class="head"><p>Conversion API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Simple type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">tainted&lt;int,</span> <span class="pre">rlbox_noop_sandbox&gt;</span></code></p></td>
<td><p>Automatic conversion. No code change needed.</p></td>
</tr>
<tr class="row-odd"><td><p>Pointer to type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Foo*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">tainted&lt;Foo*,</span> <span class="pre">rlbox_noop_sandbox&gt;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sandbox.UNSAFE_accept_pointer(ptr)</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="standard-library">
<span id="stdlib"></span><h2><a class="toc-backref" href="#id19"><span class="sectnum">2.7</span> Standard library</a><a class="headerlink" href="#standard-library" title="Permalink to this headline">¶</a></h2>
<p>RLBox provides several helper functions to application for handling tainted data
(memory influenced by or located in sandoxed regions) similar to the C/C++
standard library. We list a few of these below; they operate similar to the
standard library equivalents, but they accept tainted data.</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num">
<span id="_CPPv3I0000I00E0EN5rlbox6memsetER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num"></span><span id="_CPPv2I0000I00E0EN5rlbox6memsetER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Rhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Val</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Num</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Wrap</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="rlbox__stdlib_8hpp_1af0b5f0c8440629ae8a6e93dfa3134e32"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Rhs"><span class="n"><span class="pre">T_Rhs</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">memset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sandbox</span></span>, <a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Rhs"><span class="n"><span class="pre">T_Rhs</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ptr</span></span>, <a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Val"><span class="n"><span class="pre">T_Val</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span>, <a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="rlbox::memset::T_Num"><span class="n"><span class="pre">T_Num</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0000I00E0EN5rlbox6memsetE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Val5T_Num" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill sandbox memory with a constant byte. </p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num">
<span id="_CPPv3I0000I00E0EN5rlbox6memcpyER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num"></span><span id="_CPPv2I0000I00E0EN5rlbox6memcpyER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Rhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Lhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Num</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Wrap</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="rlbox__stdlib_8hpp_1abe93d14b246dea845ad767b2e149d1ec"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Rhs"><span class="n"><span class="pre">T_Rhs</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">memcpy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sandbox</span></span>, <a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Rhs"><span class="n"><span class="pre">T_Rhs</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dest</span></span>, <a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Lhs"><span class="n"><span class="pre">T_Lhs</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">src</span></span>, <a class="reference internal" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="rlbox::memcpy::T_Num"><span class="n"><span class="pre">T_Num</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0000I00E0EN5rlbox6memcpyE6T_WrapIP5T_Rhs5T_SbxER13rlbox_sandboxI5T_SbxE6T_WrapIP5T_Rhs5T_SbxE5T_Lhs5T_Num" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy to sandbox memory area. Note that memcpy is meant to be called on byte arrays does not adjust data according to ABI differences. If the programmer does accidentally call memcpy on buffers that needs ABI adjustment, this may cause compatibility issues, but will not cause a security issue as the destination is always a tainted or <a class="reference internal" href="#classrlbox_1_1tainted__volatile"><span class="std std-ref">tainted_volatile</span></a> pointer. </p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I000I00E0EN5rlbox24sandbox_reinterpret_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE">
<span id="_CPPv3I000I00E0EN5rlbox24sandbox_reinterpret_castERK6T_WrapI5T_Rhs5T_SbxE"></span><span id="_CPPv2I000I00E0EN5rlbox24sandbox_reinterpret_castERK6T_WrapI5T_Rhs5T_SbxE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Lhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Rhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Wrap</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="rlbox__stdlib_8hpp_1aefe733fc681a06dbe3c480e7deb3652b"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox7taintedE" title="rlbox::tainted"><span class="n"><span class="pre">tainted</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox24sandbox_reinterpret_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_reinterpret_cast::T_Lhs"><span class="n"><span class="pre">T_Lhs</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox24sandbox_reinterpret_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_reinterpret_cast::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sandbox_reinterpret_cast</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox24sandbox_reinterpret_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_reinterpret_cast::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox24sandbox_reinterpret_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_reinterpret_cast::T_Rhs"><span class="n"><span class="pre">T_Rhs</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox24sandbox_reinterpret_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_reinterpret_cast::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">rhs</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">noexcept</span></span><a class="headerlink" href="#_CPPv4I000I00E0EN5rlbox24sandbox_reinterpret_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The equivalent of a reinterpret_cast but operates on sandboxed values. </p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I000I00E0EN5rlbox18sandbox_const_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE">
<span id="_CPPv3I000I00E0EN5rlbox18sandbox_const_castERK6T_WrapI5T_Rhs5T_SbxE"></span><span id="_CPPv2I000I00E0EN5rlbox18sandbox_const_castERK6T_WrapI5T_Rhs5T_SbxE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Lhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Rhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Wrap</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="rlbox__stdlib_8hpp_1ace10de298dc1540b4cc472879e727953"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox7taintedE" title="rlbox::tainted"><span class="n"><span class="pre">tainted</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox18sandbox_const_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_const_cast::T_Lhs"><span class="n"><span class="pre">T_Lhs</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox18sandbox_const_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_const_cast::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sandbox_const_cast</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox18sandbox_const_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_const_cast::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox18sandbox_const_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_const_cast::T_Rhs"><span class="n"><span class="pre">T_Rhs</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox18sandbox_const_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_const_cast::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">rhs</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">noexcept</span></span><a class="headerlink" href="#_CPPv4I000I00E0EN5rlbox18sandbox_const_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The equivalent of a const_cast but operates on sandboxed values. </p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I000I00E0EN5rlbox19sandbox_static_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE">
<span id="_CPPv3I000I00E0EN5rlbox19sandbox_static_castERK6T_WrapI5T_Rhs5T_SbxE"></span><span id="_CPPv2I000I00E0EN5rlbox19sandbox_static_castERK6T_WrapI5T_Rhs5T_SbxE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Lhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Rhs</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Wrap</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="rlbox__stdlib_8hpp_1ab4cf87b3f39688664fbdf108b0735f37"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox7taintedE" title="rlbox::tainted"><span class="n"><span class="pre">tainted</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox19sandbox_static_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_static_cast::T_Lhs"><span class="n"><span class="pre">T_Lhs</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox19sandbox_static_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_static_cast::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sandbox_static_cast</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox19sandbox_static_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_static_cast::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox19sandbox_static_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_static_cast::T_Rhs"><span class="n"><span class="pre">T_Rhs</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I000I00E0EN5rlbox19sandbox_static_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="rlbox::sandbox_static_cast::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">rhs</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">noexcept</span></span><a class="headerlink" href="#_CPPv4I000I00E0EN5rlbox19sandbox_static_castE7taintedI5T_Lhs5T_SbxERK6T_WrapI5T_Rhs5T_SbxE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The equivalent of a static_cast but operates on sandboxed values. </p>
</dd></dl>

<p>RLBox also provides helper functions for allocating memory in the sandbox (resp
application) and transferring it from the application (resp sandbox) with:</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00EN5rlbox27copy_memory_or_grant_accessE7taintedIP1T5T_SbxER13rlbox_sandboxI5T_SbxEP1T6size_tbRb">
<span id="_CPPv3I00EN5rlbox27copy_memory_or_grant_accessER13rlbox_sandboxI5T_SbxEP1T6size_tbRb"></span><span id="_CPPv2I00EN5rlbox27copy_memory_or_grant_accessER13rlbox_sandboxI5T_SbxEP1T6size_tbRb"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="rlbox__stdlib_8hpp_1a226fcd5097e74fd2ae7472e42b30f770"></span><a class="reference internal" href="#_CPPv4I00EN5rlbox7taintedE" title="rlbox::tainted"><span class="n"><span class="pre">tainted</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00EN5rlbox27copy_memory_or_grant_accessE7taintedIP1T5T_SbxER13rlbox_sandboxI5T_SbxEP1T6size_tbRb" title="rlbox::copy_memory_or_grant_access::T"><span class="n"><span class="pre">T</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00EN5rlbox27copy_memory_or_grant_accessE7taintedIP1T5T_SbxER13rlbox_sandboxI5T_SbxEP1T6size_tbRb" title="rlbox::copy_memory_or_grant_access::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">copy_memory_or_grant_access</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00EN5rlbox27copy_memory_or_grant_accessE7taintedIP1T5T_SbxER13rlbox_sandboxI5T_SbxEP1T6size_tbRb" title="rlbox::copy_memory_or_grant_access::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sandbox</span></span>, <a class="reference internal" href="#_CPPv4I00EN5rlbox27copy_memory_or_grant_accessE7taintedIP1T5T_SbxER13rlbox_sandboxI5T_SbxEP1T6size_tbRb" title="rlbox::copy_memory_or_grant_access::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">free_source_on_copy</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">copied</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN5rlbox27copy_memory_or_grant_accessE7taintedIP1T5T_SbxER13rlbox_sandboxI5T_SbxEP1T6size_tbRb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function either. </p>
<p><ul class="simple">
<li><p>copies the given buffer into the sandbox calling delete on the src OR</p></li>
<li><p>if the sandbox allows, adds the buffer to the existing sandbox memory </p></li>
</ul>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sandbox</strong> – Target sandbox </p></li>
<li><p><strong>src</strong> – Raw pointer to the buffer </p></li>
<li><p><strong>num</strong> – Number of bytes in the buffer </p></li>
<li><p><strong>free_source_on_copy</strong> – If the source buffer was copied, this variable controls whether copy_memory_or_grant_access should call delete on the src. This calls delete[] if num &gt; 1. </p></li>
<li><p><strong>copied</strong> – out parameter indicating if the source was copied or transfered </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00I00E0EN5rlbox26copy_memory_or_deny_accessEP1TR13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb">
<span id="_CPPv3I00I00E0EN5rlbox26copy_memory_or_deny_accessER13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb"></span><span id="_CPPv2I00I00E0EN5rlbox26copy_memory_or_deny_accessER13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Sbx</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">T_Wrap</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="target" id="rlbox__stdlib_8hpp_1ab0daedc0f90aa6d424cb8e23bd752ac2"></span><a class="reference internal" href="#_CPPv4I00I00E0EN5rlbox26copy_memory_or_deny_accessEP1TR13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb" title="rlbox::copy_memory_or_deny_access::T"><span class="n"><span class="pre">T</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><span class="n"><span class="pre">rlbox</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">copy_memory_or_deny_access</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN5rlbox13rlbox_sandboxE" title="rlbox::rlbox_sandbox"><span class="n"><span class="pre">rlbox_sandbox</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00I00E0EN5rlbox26copy_memory_or_deny_accessEP1TR13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb" title="rlbox::copy_memory_or_deny_access::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sandbox</span></span>, <a class="reference internal" href="#_CPPv4I00I00E0EN5rlbox26copy_memory_or_deny_accessEP1TR13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb" title="rlbox::copy_memory_or_deny_access::T_Wrap"><span class="n"><span class="pre">T_Wrap</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00I00E0EN5rlbox26copy_memory_or_deny_accessEP1TR13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb" title="rlbox::copy_memory_or_deny_access::T"><span class="n"><span class="pre">T</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00I00E0EN5rlbox26copy_memory_or_deny_accessEP1TR13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb" title="rlbox::copy_memory_or_deny_access::T_Sbx"><span class="n"><span class="pre">T_Sbx</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">free_source_on_copy</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">copied</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00I00E0EN5rlbox26copy_memory_or_deny_accessEP1TR13rlbox_sandboxI5T_SbxE6T_WrapIP1T5T_SbxE6size_tbRb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This function either. </p>
<p><ul class="simple">
<li><p>copies the given buffer out of the sandbox calling free_in_sandbox on the src OR</p></li>
<li><p>if the sandbox allows, moves the buffer out of existing sandbox memory </p></li>
</ul>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sandbox</strong> – Target sandbox </p></li>
<li><p><strong>src</strong> – Raw pointer to the buffer </p></li>
<li><p><strong>num</strong> – Number of bytes in the buffer </p></li>
<li><p><strong>free_source_on_copy</strong> – If the source buffer was copied, this variable controls whether copy_memory_or_grant_access should call delete on the src. This calls delete[] if num &gt; 1. </p></li>
<li><p><strong>copied</strong> – out parameter indicating if the source was copied or transfered </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>These functions copy when using a sandbox like Wasm. For the nop-sandbox, they
don’t copy and only move pointers, though.</p>
</section>
</section>
<section id="handling-more-complex-abis">
<h1><a class="toc-backref" href="#id20"><span class="sectnum">3</span> Handling more complex ABIs</a><a class="headerlink" href="#handling-more-complex-abis" title="Permalink to this headline">¶</a></h1>
<section id="passing-structs-to-from-a-sandbox">
<h2><a class="toc-backref" href="#id21"><span class="sectnum">3.1</span> Passing structs to/from a sandbox</a><a class="headerlink" href="#passing-structs-to-from-a-sandbox" title="Permalink to this headline">¶</a></h2>
<p>RLBox currently doesn’t automatically let you use fields of structs.  To use
fields of a tainted struct you need to essentially tell RLBox about the struct
type and layout. You typically do this in a separate header file and include
this file in your application code as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">app</span> <span class="n">code</span><span class="p">:</span>

<span class="c1">#include &quot;lib_struct_file.h&quot;</span>
<span class="n">rlbox_load_structs_from_library</span><span class="p">(</span><span class="n">mylib</span><span class="p">);</span>
</pre></div>
</div>
<p>The first line includes the header file (we will populate shortly).  The second
line loads the struct definitions using the library name <code class="docutils literal notranslate"><span class="pre">mylib</span></code>.</p>
<p>Let’s suppose our library has two structs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">mylib</span><span class="o">.</span><span class="n">h</span><span class="p">:</span>

<span class="n">struct</span> <span class="n">Inner</span> <span class="p">{</span>
   <span class="nb">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">Foo</span> <span class="p">{</span>
   <span class="n">unsigned</span> <span class="n">char</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="n">status_array</span><span class="p">;</span>
   <span class="n">Inner</span> <span class="n">internal</span><span class="p">;</span>
   <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">width</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">_lib_struct_file.h</span></code> you will then provide a definition for <code class="docutils literal notranslate"><span class="pre">Foo</span></code> alone
would be as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="c1">#define sandbox_fields_reflection_mylib_class_Foo(f, g, ...)         \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">status_array</span><span class="p">,</span> <span class="n">FIELD_NORMAL</span><span class="p">,</span> <span class="c1">##__VA_ARGS__) g() \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">Inner</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">FIELD_NORMAL</span><span class="p">,</span> <span class="c1">##__VA_ARGS__) g()                \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">FIELD_NORMAL</span><span class="p">,</span> <span class="c1">##__VA_ARGS__) g()</span>

<span class="c1">#define sandbox_fields_reflection_mylib_allClasses(f, ...)  \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">mylib</span><span class="p">,</span> <span class="c1">##__VA_ARGS__)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">Foo</span></code> has an <code class="docutils literal notranslate"><span class="pre">Inner</span></code> struct, though, we’ll need to also provide a
definition for this struct if we want to access the <code class="docutils literal notranslate"><span class="pre">val</span></code> value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="c1">#define sandbox_fields_reflection_mylib_class_Inner(f, g, ...)    \</span>
  <span class="n">f</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">FIELD_NORMAL</span><span class="p">,</span> <span class="c1">##__VA_ARGS__) g()</span>

<span class="c1">#define sandbox_fields_reflection_mylib_class_Foo(f, g, ...)         \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">status_array</span><span class="p">,</span> <span class="n">FIELD_NORMAL</span><span class="p">,</span> <span class="c1">##__VA_ARGS__) g() \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">Inner</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">FIELD_NORMAL</span><span class="p">,</span> <span class="c1">##__VA_ARGS__) g()                \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">FIELD_NORMAL</span><span class="p">,</span> <span class="c1">##__VA_ARGS__) g()</span>

<span class="c1">#define sandbox_fields_reflection_mylib_allClasses(f, ...)  \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">Inner</span><span class="p">,</span> <span class="n">mylib</span><span class="p">,</span> <span class="c1">##__VA_ARGS__)                            \</span>
  <span class="n">f</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">mylib</span><span class="p">,</span> <span class="c1">##__VA_ARGS__)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Each struct file is intended to hold all struct definitions associated with
a library.</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>The compiler currently doesn’t catch type mismatches, missing
members, or incorrectly ordered members in the struct definition.</p>
</div>
<p>Take a look at the <a class="reference external" href="https://searchfox.org/mozilla-central/source/media/libogg/geckoextra/include/OggStructsForRLBox.h">ogg struct layout in Firefox</a>
for a complete example.</p>
<p>In the future we will likely generate these kinds of files automatically.</p>
</section>
<section id="invoking-varargs-functions">
<h2><a class="toc-backref" href="#id22"><span class="sectnum">3.2</span> Invoking varargs functions</a><a class="headerlink" href="#invoking-varargs-functions" title="Permalink to this headline">¶</a></h2>
<p>RLBox does not (yet) support calling functions with variable arguments
currently. So, if the library you are sandboxing has APIs with variable
arguments you need to monomorphize the usages. Specifically, you need to create
wrapper functions for each usage you wish to expose.  Consider the following
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Original</span> <span class="n">library</span> <span class="n">function</span><span class="p">:</span>
<span class="nb">int</span> <span class="n">example_call</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="nb">int</span> <span class="n">y</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>

<span class="o">...</span>

<span class="o">//</span> <span class="n">Original</span> <span class="n">invocations</span> <span class="ow">in</span> <span class="n">application</span> <span class="n">code</span><span class="p">:</span>
<span class="n">rv</span> <span class="o">=</span> <span class="n">example_call</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">RESET_FLAG</span><span class="p">);</span>
<span class="n">rv</span> <span class="o">=</span> <span class="n">example_call</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">INVERT_FLAG</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>One way to handle this in RLBox is to expose two functions as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">example_call_reset</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="nb">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">example_call</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">example_call_invert</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">,</span> <span class="nb">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="n">flag</span><span class="p">,</span> <span class="n">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">example_call</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, you can call them as usual:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rv</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">example_call_reset</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">RESET_FLAG</span><span class="p">);</span>
<span class="n">rv</span> <span class="o">=</span> <span class="n">sandbox</span><span class="o">.</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="n">example_call_invert</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">INVERT_FLAG</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="invoking-c-functions-in-a-sandbox">
<h2><a class="toc-backref" href="#id23"><span class="sectnum">3.3</span> Invoking C++ functions in a sandbox</a><a class="headerlink" href="#invoking-c-functions-in-a-sandbox" title="Permalink to this headline">¶</a></h2>
<p>RLBox does not currently let you invoke C++ library functions directly. Instead
you need to expose a C ABI. Functions are largely straightforward. Methods
require a bit of work since the receiver object is implicit: The simplest way
to do this for class methods is to expose C functions and just pass a pointer
to the receiver object as the first argument.</p>
</section>
<section id="passing-application-pointers-into-the-sandbox-with-app-pointer">
<h2><a class="toc-backref" href="#id24"><span class="sectnum">3.4</span> Passing application pointers into the sandbox with <cite>app_pointer</cite></a><a class="headerlink" href="#passing-application-pointers-into-the-sandbox-with-app-pointer" title="Permalink to this headline">¶</a></h2>
<p>It’s sometimes useful to pass application pointers into the sandbox. For
example, you may need to pass a pointer to the receiver (<code class="docutils literal notranslate"><span class="pre">this</span></code>) so sandbox
library can pass this pointer back in a callback. We can’t trust the sandbox with
actual applications pointers. RLBox instead provides a level of indirection.</p>
<p>If you want to pass a pointer into the sandbox you can use the
<cite>get_app_pointer() &lt;get_app_pointer&gt;</cite> API, which returns an <cite>app_pointer</cite>. For
example, in the expat library we need to pass a pointer to the receiver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mAppPtr</span> <span class="o">=</span> <span class="n">mSandbox</span><span class="o">-&gt;</span><span class="n">get_app_pointer</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">));</span>
<span class="o">//</span> <span class="n">convert</span> <span class="n">the</span> <span class="n">app_pointer</span> <span class="n">to</span> <span class="n">tainted</span>
<span class="n">tainted_expat</span><span class="o">&lt;</span><span class="n">void</span><span class="o">*&gt;</span> <span class="n">t_driver</span> <span class="o">=</span> <span class="n">mAppPtr</span><span class="o">.</span><span class="n">to_tainted</span><span class="p">();</span>
<span class="o">//</span> <span class="n">call</span> <span class="n">function</span> <span class="k">as</span> <span class="n">usual</span><span class="p">:</span>
<span class="n">mSandbox</span><span class="o">-&gt;</span><span class="n">invoke_sandbox_function</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">t_driver</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mAppPtr</span></code> is a member of the class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">app_pointer_expat</span><span class="o">&lt;</span><span class="n">void</span><span class="o">*&gt;</span> <span class="n">mAppPtr</span><span class="p">;</span>
</pre></div>
</div>
<p>Internally, RLBox keeps a map between app pointers and the corresponding
tainted pointers exposed to the sandbox. This lets you lookup the pointers in
callbacks, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">callback</span><span class="p">(</span><span class="n">rlbox_sandbox_expat</span><span class="o">&amp;</span> <span class="n">aSandbox</span><span class="p">,</span> <span class="o">...</span> <span class="n">tainted_expat</span><span class="o">&lt;</span><span class="n">void</span><span class="o">*&gt;</span> <span class="n">t_driver</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">nsExpatDriver</span><span class="o">*</span> <span class="bp">self</span> <span class="o">=</span> <span class="n">aSandbox</span><span class="o">.</span><span class="n">lookup_app_ptr</span><span class="p">(</span><span class="n">rlbox</span><span class="p">::</span><span class="n">sandbox_static_cast</span><span class="o">&lt;</span><span class="n">nsExpatDriver</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">t_driver</span><span class="p">));</span>
</pre></div>
</div>
<p>Like callbacks, you need to keep app pointers alive and unregister them when
you’re done:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mAppPtr</span><span class="o">.</span><span class="n">unregister</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="additional-material">
<span id="plugins"></span><h1><a class="toc-backref" href="#id25"><span class="sectnum">4</span> Additional material</a><a class="headerlink" href="#additional-material" title="Permalink to this headline">¶</a></h1>
<p>Here is some additional material on how to use RLBox.</p>
<ul class="simple">
<li><p>A good next step after this tutorial is to get hands-on migrating an application
to using a library that you want to sandbox. The <a class="reference external" href="https://github.com/shravanrn/simple_library_example">simple library example repo</a> is a “toy” application
that uses a potentially “buggy” library. Try migrating the application to use
the RLBox API based on what you’ve learnt in this tutorial. The solution is
available in the solution folder in the same repo.</p></li>
<li><p>Here is an <a class="reference external" href="https://github.com/ayushagarwal95/tutorial-rlbox">alternate short tutorial</a> on using the RLBox APIs.
Note that this tutorial uses an alternate RLBox sandbox plugin (which uses the
Lucet Wasm compiler and RLBox plugin rather than the wasm2c based plugin
recommended in this tutorial, but this does not affect the use of the RLBox APIs
themselves).</p></li>
<li><p>Another useful example of using the RLBox APIs is the <a class="reference external" href="https://github.com/PLSysSec/rlbox_sandboxing_api/tree/master/code/tests">RLBox test suite</a>
itself.</p></li>
<li><p>You can also see usage of the RLBox APIs in the Firefox browser by using the
<a class="reference external" href="https://searchfox.org/mozilla-central/search?q=create_sandbox&amp;path=">Firefox code search</a>.</p></li>
<li><p>Finally, the academic paper discussing the development of RLBox and its use in
Firefox [RLBoxPaper] at the USENIX Security conference 2020 and the accompanying
<a class="reference external" href="https://cns.ucsd.edu/videos/members/CNS-RR-2020/Captioned/2020_10_15_CNS_Narayan.mp4">video explanations</a>
are a good way to get an overview of RLBox.</p></li>
</ul>
</section>
<section id="references">
<h1><a class="toc-backref" href="#id26"><span class="sectnum">5</span> References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<dl class="citation">
<dt class="label" id="rlboxpaper"><span class="brackets">RLBoxPaper</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://usenix2020.rlbox.dev">Retrofitting Fine Grain Isolation in the Firefox Renderer</a>
by S. Narayan, C. Disselkoen, T. Garfinkel, S. Lerner, H. Shacham, D. Stefan</p>
</dd>
<dt class="label" id="rlboxlogin"><span class="brackets"><a class="fn-backref" href="#id2">RLBoxLogin</a></span></dt>
<dd><p><a class="reference external" href="https://www.usenix.org/publications/login/winter2020/garfinkel-tal">The Road to Less Trusted Code: Lowering the Barrier to In-Process Sandboxing</a></p>
</dd>
<dt class="label" id="rlboxfirefox"><span class="brackets"><a class="fn-backref" href="#id3">RLBoxFirefox</a></span></dt>
<dd><p><a class="reference external" href="https://hacks.mozilla.org/2020/02/securing-firefox-with-webassembly/">Securing Firefox with WebAssembly</a> by N. Froyd</p>
</dd>
<dt class="label" id="doxygen"><span class="brackets">Doxygen</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://doxygen.rlbox.dev/">RLBox Doxygen Documentation</a></p>
</dd>
</dl>
</section>
<section id="indices-and-tables">
<h1><a class="toc-backref" href="#id27"><span class="sectnum">6</span> Indices and tables</a><a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">RLBox Sandboxing API</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, RLBox_AUTHOR.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>